// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: data.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  Address,
  B256,
  B384,
  U128,
  U256,
  ValidatorStatus,
  validatorStatusFromJSON,
  validatorStatusToJSON,
} from "./common";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "beaconchain.v2";

/** Beacon Chain DNA definitions (data). */

/** Requested data, grouped by block. */
export interface Block {
  /** The header. */
  readonly header?:
    | BlockHeader
    | undefined;
  /** List of transactions. */
  readonly transactions?:
    | readonly Transaction[]
    | undefined;
  /** List of validators. */
  readonly validators?:
    | readonly Validator[]
    | undefined;
  /** List of blobs. */
  readonly blobs?: readonly Blob[] | undefined;
}

export interface BlockHeader {
  readonly slot?: bigint | undefined;
  readonly proposerIndex?: number | undefined;
  readonly parentRoot?: B256 | undefined;
  readonly stateRoot?: B256 | undefined;
  readonly randaoReveal?: Uint8Array | undefined;
  readonly depositCount?: bigint | undefined;
  readonly depositRoot?: B256 | undefined;
  readonly blockHash?: B256 | undefined;
  readonly graffiti?: B256 | undefined;
  readonly executionPayload?: ExecutionPayload | undefined;
  readonly blobKzgCommitments?: readonly B384[] | undefined;
}

export interface Transaction {
  /** Transaction hash. */
  readonly hash?:
    | B256
    | undefined;
  /** Nonce. */
  readonly nonce?:
    | bigint
    | undefined;
  /** Transaction index in the block. */
  readonly transactionIndex?:
    | bigint
    | undefined;
  /** Sender. */
  readonly from?:
    | Address
    | undefined;
  /** Recipient. */
  readonly to?:
    | Address
    | undefined;
  /** Amount of wei transferred. */
  readonly value?:
    | U256
    | undefined;
  /** Gas price. */
  readonly gasPrice?:
    | U128
    | undefined;
  /** Gas amount. */
  readonly gas?:
    | U256
    | undefined;
  /** Max base fee per gas the sender is willing to pay. */
  readonly maxFeePerGas?:
    | U128
    | undefined;
  /** Miner's tip. */
  readonly maxPriorityFeePerGas?:
    | U128
    | undefined;
  /** Data. */
  readonly input?:
    | Uint8Array
    | undefined;
  /** The signature's r,s,v,yParity values. */
  readonly signature?:
    | Signature
    | undefined;
  /** Chain ID. */
  readonly chainId?:
    | bigint
    | undefined;
  /** EIP-2930 access list. */
  readonly accessList?:
    | readonly AccessListItem[]
    | undefined;
  /** EIP-2718 transaction type. */
  readonly transactionType?:
    | bigint
    | undefined;
  /** EIP-4844 max gas fee per blob. */
  readonly maxFeePerBlobGas?:
    | U128
    | undefined;
  /** EIP-4844 blob hashes. */
  readonly blobVersionedHashes?: readonly B256[] | undefined;
}

export interface Validator {
  readonly validatorIndex?: number | undefined;
  readonly balance?: bigint | undefined;
  readonly status?: ValidatorStatus | undefined;
  readonly pubkey?: B384 | undefined;
  readonly withdrawalCredentials?: B256 | undefined;
  readonly effectiveBalance?: bigint | undefined;
  readonly slashed?: boolean | undefined;
  readonly activationEligibilityEpoch?: bigint | undefined;
  readonly activationEpoch?: bigint | undefined;
  readonly exitEpoch?: bigint | undefined;
  readonly withdrawableEpoch?: bigint | undefined;
}

export interface Blob {
  /** Blob index in the block. */
  readonly blobIndex?:
    | number
    | undefined;
  /** Blob data. */
  readonly blob?:
    | Uint8Array
    | undefined;
  /** KZG commitment. */
  readonly kzgCommitment?:
    | B384
    | undefined;
  /** KZG proof. */
  readonly kzgProof?:
    | B384
    | undefined;
  /** KZG commitment inclusion proof. */
  readonly kzgCommitmentInclusionProof?:
    | readonly B256[]
    | undefined;
  /** Blob hash. */
  readonly blobHash?: B256 | undefined;
}

export interface ExecutionPayload {
  /** Parent block hash. */
  readonly parentHash?:
    | B256
    | undefined;
  /** Address of the fee recipient. */
  readonly feeRecipient?:
    | Address
    | undefined;
  /** State root. */
  readonly stateRoot?:
    | B256
    | undefined;
  /** Receipts root. */
  readonly receiptsRoot?:
    | B256
    | undefined;
  /** Logs bloom. */
  readonly logsBloom?:
    | Uint8Array
    | undefined;
  /** Previous RANDAO. */
  readonly prevRandao?:
    | B256
    | undefined;
  /** Block number. */
  readonly blockNumber?:
    | bigint
    | undefined;
  /** Block timestamp. */
  readonly timestamp?: Date | undefined;
}

export interface Signature {
  /** The signature's r value. */
  readonly r?:
    | U256
    | undefined;
  /** The signature's s value. */
  readonly s?:
    | U256
    | undefined;
  /** The signature's v value. */
  readonly v?:
    | U256
    | undefined;
  /** The signature's parity byte. */
  readonly yParity?: boolean | undefined;
}

export interface AccessListItem {
  /** Account address to be loaded at the start of the transaction. */
  readonly address?:
    | Address
    | undefined;
  /** Storage keys to be loaded at the start of the transaction. */
  readonly storageKeys?: readonly B256[] | undefined;
}

function createBaseBlock(): Block {
  return { header: undefined, transactions: [], validators: [], blobs: [] };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactions !== undefined && message.transactions.length !== 0) {
      for (const v of message.transactions) {
        Transaction.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.validators !== undefined && message.validators.length !== 0) {
      for (const v of message.validators) {
        Validator.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.blobs !== undefined && message.blobs.length !== 0) {
      for (const v of message.blobs) {
        Blob.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions!.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.validators!.push(Validator.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blobs!.push(Blob.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => Validator.fromJSON(e))
        : [],
      blobs: globalThis.Array.isArray(object?.blobs) ? object.blobs.map((e: any) => Blob.fromJSON(e)) : [],
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => Validator.toJSON(e));
    }
    if (message.blobs?.length) {
      obj.blobs = message.blobs.map((e) => Blob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock() as any;
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.validators = object.validators?.map((e) => Validator.fromPartial(e)) || [];
    message.blobs = object.blobs?.map((e) => Blob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    slot: BigInt("0"),
    proposerIndex: 0,
    parentRoot: undefined,
    stateRoot: undefined,
    randaoReveal: new Uint8Array(0),
    depositCount: BigInt("0"),
    depositRoot: undefined,
    blockHash: undefined,
    graffiti: undefined,
    executionPayload: undefined,
    blobKzgCommitments: [],
  };
}

export const BlockHeader = {
  encode(message: BlockHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slot !== undefined && message.slot !== BigInt("0")) {
      if (BigInt.asUintN(64, message.slot) !== message.slot) {
        throw new globalThis.Error("value provided for field message.slot of type uint64 too large");
      }
      writer.uint32(8).uint64(message.slot.toString());
    }
    if (message.proposerIndex !== undefined && message.proposerIndex !== 0) {
      writer.uint32(16).uint32(message.proposerIndex);
    }
    if (message.parentRoot !== undefined) {
      B256.encode(message.parentRoot, writer.uint32(26).fork()).ldelim();
    }
    if (message.stateRoot !== undefined) {
      B256.encode(message.stateRoot, writer.uint32(34).fork()).ldelim();
    }
    if (message.randaoReveal !== undefined && message.randaoReveal.length !== 0) {
      writer.uint32(42).bytes(message.randaoReveal);
    }
    if (message.depositCount !== undefined && message.depositCount !== BigInt("0")) {
      if (BigInt.asUintN(64, message.depositCount) !== message.depositCount) {
        throw new globalThis.Error("value provided for field message.depositCount of type uint64 too large");
      }
      writer.uint32(48).uint64(message.depositCount.toString());
    }
    if (message.depositRoot !== undefined) {
      B256.encode(message.depositRoot, writer.uint32(58).fork()).ldelim();
    }
    if (message.blockHash !== undefined) {
      B256.encode(message.blockHash, writer.uint32(66).fork()).ldelim();
    }
    if (message.graffiti !== undefined) {
      B256.encode(message.graffiti, writer.uint32(74).fork()).ldelim();
    }
    if (message.executionPayload !== undefined) {
      ExecutionPayload.encode(message.executionPayload, writer.uint32(82).fork()).ldelim();
    }
    if (message.blobKzgCommitments !== undefined && message.blobKzgCommitments.length !== 0) {
      for (const v of message.blobKzgCommitments) {
        B384.encode(v!, writer.uint32(90).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slot = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.proposerIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentRoot = B256.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stateRoot = B256.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.randaoReveal = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.depositCount = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.depositRoot = B256.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.blockHash = B256.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.graffiti = B256.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.executionPayload = ExecutionPayload.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.blobKzgCommitments!.push(B384.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      slot: isSet(object.slot) ? BigInt(object.slot) : BigInt("0"),
      proposerIndex: isSet(object.proposerIndex) ? globalThis.Number(object.proposerIndex) : 0,
      parentRoot: isSet(object.parentRoot) ? B256.fromJSON(object.parentRoot) : undefined,
      stateRoot: isSet(object.stateRoot) ? B256.fromJSON(object.stateRoot) : undefined,
      randaoReveal: isSet(object.randaoReveal) ? bytesFromBase64(object.randaoReveal) : new Uint8Array(0),
      depositCount: isSet(object.depositCount) ? BigInt(object.depositCount) : BigInt("0"),
      depositRoot: isSet(object.depositRoot) ? B256.fromJSON(object.depositRoot) : undefined,
      blockHash: isSet(object.blockHash) ? B256.fromJSON(object.blockHash) : undefined,
      graffiti: isSet(object.graffiti) ? B256.fromJSON(object.graffiti) : undefined,
      executionPayload: isSet(object.executionPayload) ? ExecutionPayload.fromJSON(object.executionPayload) : undefined,
      blobKzgCommitments: globalThis.Array.isArray(object?.blobKzgCommitments)
        ? object.blobKzgCommitments.map((e: any) => B384.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.slot !== undefined && message.slot !== BigInt("0")) {
      obj.slot = message.slot.toString();
    }
    if (message.proposerIndex !== undefined && message.proposerIndex !== 0) {
      obj.proposerIndex = Math.round(message.proposerIndex);
    }
    if (message.parentRoot !== undefined) {
      obj.parentRoot = B256.toJSON(message.parentRoot);
    }
    if (message.stateRoot !== undefined) {
      obj.stateRoot = B256.toJSON(message.stateRoot);
    }
    if (message.randaoReveal !== undefined && message.randaoReveal.length !== 0) {
      obj.randaoReveal = base64FromBytes(message.randaoReveal);
    }
    if (message.depositCount !== undefined && message.depositCount !== BigInt("0")) {
      obj.depositCount = message.depositCount.toString();
    }
    if (message.depositRoot !== undefined) {
      obj.depositRoot = B256.toJSON(message.depositRoot);
    }
    if (message.blockHash !== undefined) {
      obj.blockHash = B256.toJSON(message.blockHash);
    }
    if (message.graffiti !== undefined) {
      obj.graffiti = B256.toJSON(message.graffiti);
    }
    if (message.executionPayload !== undefined) {
      obj.executionPayload = ExecutionPayload.toJSON(message.executionPayload);
    }
    if (message.blobKzgCommitments?.length) {
      obj.blobKzgCommitments = message.blobKzgCommitments.map((e) => B384.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeader>): BlockHeader {
    return BlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeader>): BlockHeader {
    const message = createBaseBlockHeader() as any;
    message.slot = object.slot ?? BigInt("0");
    message.proposerIndex = object.proposerIndex ?? 0;
    message.parentRoot = (object.parentRoot !== undefined && object.parentRoot !== null)
      ? B256.fromPartial(object.parentRoot)
      : undefined;
    message.stateRoot = (object.stateRoot !== undefined && object.stateRoot !== null)
      ? B256.fromPartial(object.stateRoot)
      : undefined;
    message.randaoReveal = object.randaoReveal ?? new Uint8Array(0);
    message.depositCount = object.depositCount ?? BigInt("0");
    message.depositRoot = (object.depositRoot !== undefined && object.depositRoot !== null)
      ? B256.fromPartial(object.depositRoot)
      : undefined;
    message.blockHash = (object.blockHash !== undefined && object.blockHash !== null)
      ? B256.fromPartial(object.blockHash)
      : undefined;
    message.graffiti = (object.graffiti !== undefined && object.graffiti !== null)
      ? B256.fromPartial(object.graffiti)
      : undefined;
    message.executionPayload = (object.executionPayload !== undefined && object.executionPayload !== null)
      ? ExecutionPayload.fromPartial(object.executionPayload)
      : undefined;
    message.blobKzgCommitments = object.blobKzgCommitments?.map((e) => B384.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    hash: undefined,
    nonce: BigInt("0"),
    transactionIndex: BigInt("0"),
    from: undefined,
    to: undefined,
    value: undefined,
    gasPrice: undefined,
    gas: undefined,
    maxFeePerGas: undefined,
    maxPriorityFeePerGas: undefined,
    input: new Uint8Array(0),
    signature: undefined,
    chainId: BigInt("0"),
    accessList: [],
    transactionType: BigInt("0"),
    maxFeePerBlobGas: undefined,
    blobVersionedHashes: [],
  };
}

export const Transaction = {
  encode(message: Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined) {
      B256.encode(message.hash, writer.uint32(10).fork()).ldelim();
    }
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(16).uint64(message.nonce.toString());
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== BigInt("0")) {
      if (BigInt.asUintN(64, message.transactionIndex) !== message.transactionIndex) {
        throw new globalThis.Error("value provided for field message.transactionIndex of type uint64 too large");
      }
      writer.uint32(24).uint64(message.transactionIndex.toString());
    }
    if (message.from !== undefined) {
      Address.encode(message.from, writer.uint32(34).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Address.encode(message.to, writer.uint32(42).fork()).ldelim();
    }
    if (message.value !== undefined) {
      U256.encode(message.value, writer.uint32(50).fork()).ldelim();
    }
    if (message.gasPrice !== undefined) {
      U128.encode(message.gasPrice, writer.uint32(58).fork()).ldelim();
    }
    if (message.gas !== undefined) {
      U256.encode(message.gas, writer.uint32(66).fork()).ldelim();
    }
    if (message.maxFeePerGas !== undefined) {
      U128.encode(message.maxFeePerGas, writer.uint32(74).fork()).ldelim();
    }
    if (message.maxPriorityFeePerGas !== undefined) {
      U128.encode(message.maxPriorityFeePerGas, writer.uint32(82).fork()).ldelim();
    }
    if (message.input !== undefined && message.input.length !== 0) {
      writer.uint32(90).bytes(message.input);
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(98).fork()).ldelim();
    }
    if (message.chainId !== undefined && message.chainId !== BigInt("0")) {
      if (BigInt.asUintN(64, message.chainId) !== message.chainId) {
        throw new globalThis.Error("value provided for field message.chainId of type uint64 too large");
      }
      writer.uint32(104).uint64(message.chainId.toString());
    }
    if (message.accessList !== undefined && message.accessList.length !== 0) {
      for (const v of message.accessList) {
        AccessListItem.encode(v!, writer.uint32(114).fork()).ldelim();
      }
    }
    if (message.transactionType !== undefined && message.transactionType !== BigInt("0")) {
      if (BigInt.asUintN(64, message.transactionType) !== message.transactionType) {
        throw new globalThis.Error("value provided for field message.transactionType of type uint64 too large");
      }
      writer.uint32(120).uint64(message.transactionType.toString());
    }
    if (message.maxFeePerBlobGas !== undefined) {
      U128.encode(message.maxFeePerBlobGas, writer.uint32(130).fork()).ldelim();
    }
    if (message.blobVersionedHashes !== undefined && message.blobVersionedHashes.length !== 0) {
      for (const v of message.blobVersionedHashes) {
        B256.encode(v!, writer.uint32(138).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = B256.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.transactionIndex = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.from = Address.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = Address.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.value = U256.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gasPrice = U128.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gas = U256.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.maxFeePerGas = U128.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.maxPriorityFeePerGas = U128.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.input = reader.bytes();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.chainId = longToBigint(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.accessList!.push(AccessListItem.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.transactionType = longToBigint(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.maxFeePerBlobGas = U128.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.blobVersionedHashes!.push(B256.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      hash: isSet(object.hash) ? B256.fromJSON(object.hash) : undefined,
      nonce: isSet(object.nonce) ? BigInt(object.nonce) : BigInt("0"),
      transactionIndex: isSet(object.transactionIndex) ? BigInt(object.transactionIndex) : BigInt("0"),
      from: isSet(object.from) ? Address.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Address.fromJSON(object.to) : undefined,
      value: isSet(object.value) ? U256.fromJSON(object.value) : undefined,
      gasPrice: isSet(object.gasPrice) ? U128.fromJSON(object.gasPrice) : undefined,
      gas: isSet(object.gas) ? U256.fromJSON(object.gas) : undefined,
      maxFeePerGas: isSet(object.maxFeePerGas) ? U128.fromJSON(object.maxFeePerGas) : undefined,
      maxPriorityFeePerGas: isSet(object.maxPriorityFeePerGas) ? U128.fromJSON(object.maxPriorityFeePerGas) : undefined,
      input: isSet(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
      chainId: isSet(object.chainId) ? BigInt(object.chainId) : BigInt("0"),
      accessList: globalThis.Array.isArray(object?.accessList)
        ? object.accessList.map((e: any) => AccessListItem.fromJSON(e))
        : [],
      transactionType: isSet(object.transactionType) ? BigInt(object.transactionType) : BigInt("0"),
      maxFeePerBlobGas: isSet(object.maxFeePerBlobGas) ? U128.fromJSON(object.maxFeePerBlobGas) : undefined,
      blobVersionedHashes: globalThis.Array.isArray(object?.blobVersionedHashes)
        ? object.blobVersionedHashes.map((e: any) => B256.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = B256.toJSON(message.hash);
    }
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      obj.nonce = message.nonce.toString();
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== BigInt("0")) {
      obj.transactionIndex = message.transactionIndex.toString();
    }
    if (message.from !== undefined) {
      obj.from = Address.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Address.toJSON(message.to);
    }
    if (message.value !== undefined) {
      obj.value = U256.toJSON(message.value);
    }
    if (message.gasPrice !== undefined) {
      obj.gasPrice = U128.toJSON(message.gasPrice);
    }
    if (message.gas !== undefined) {
      obj.gas = U256.toJSON(message.gas);
    }
    if (message.maxFeePerGas !== undefined) {
      obj.maxFeePerGas = U128.toJSON(message.maxFeePerGas);
    }
    if (message.maxPriorityFeePerGas !== undefined) {
      obj.maxPriorityFeePerGas = U128.toJSON(message.maxPriorityFeePerGas);
    }
    if (message.input !== undefined && message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    if (message.chainId !== undefined && message.chainId !== BigInt("0")) {
      obj.chainId = message.chainId.toString();
    }
    if (message.accessList?.length) {
      obj.accessList = message.accessList.map((e) => AccessListItem.toJSON(e));
    }
    if (message.transactionType !== undefined && message.transactionType !== BigInt("0")) {
      obj.transactionType = message.transactionType.toString();
    }
    if (message.maxFeePerBlobGas !== undefined) {
      obj.maxFeePerBlobGas = U128.toJSON(message.maxFeePerBlobGas);
    }
    if (message.blobVersionedHashes?.length) {
      obj.blobVersionedHashes = message.blobVersionedHashes.map((e) => B256.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction() as any;
    message.hash = (object.hash !== undefined && object.hash !== null) ? B256.fromPartial(object.hash) : undefined;
    message.nonce = object.nonce ?? BigInt("0");
    message.transactionIndex = object.transactionIndex ?? BigInt("0");
    message.from = (object.from !== undefined && object.from !== null) ? Address.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Address.fromPartial(object.to) : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? U256.fromPartial(object.value) : undefined;
    message.gasPrice = (object.gasPrice !== undefined && object.gasPrice !== null)
      ? U128.fromPartial(object.gasPrice)
      : undefined;
    message.gas = (object.gas !== undefined && object.gas !== null) ? U256.fromPartial(object.gas) : undefined;
    message.maxFeePerGas = (object.maxFeePerGas !== undefined && object.maxFeePerGas !== null)
      ? U128.fromPartial(object.maxFeePerGas)
      : undefined;
    message.maxPriorityFeePerGas = (object.maxPriorityFeePerGas !== undefined && object.maxPriorityFeePerGas !== null)
      ? U128.fromPartial(object.maxPriorityFeePerGas)
      : undefined;
    message.input = object.input ?? new Uint8Array(0);
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.chainId = object.chainId ?? BigInt("0");
    message.accessList = object.accessList?.map((e) => AccessListItem.fromPartial(e)) || [];
    message.transactionType = object.transactionType ?? BigInt("0");
    message.maxFeePerBlobGas = (object.maxFeePerBlobGas !== undefined && object.maxFeePerBlobGas !== null)
      ? U128.fromPartial(object.maxFeePerBlobGas)
      : undefined;
    message.blobVersionedHashes = object.blobVersionedHashes?.map((e) => B256.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidator(): Validator {
  return {
    validatorIndex: 0,
    balance: BigInt("0"),
    status: 0,
    pubkey: undefined,
    withdrawalCredentials: undefined,
    effectiveBalance: BigInt("0"),
    slashed: false,
    activationEligibilityEpoch: BigInt("0"),
    activationEpoch: BigInt("0"),
    exitEpoch: BigInt("0"),
    withdrawableEpoch: BigInt("0"),
  };
}

export const Validator = {
  encode(message: Validator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validatorIndex !== undefined && message.validatorIndex !== 0) {
      writer.uint32(8).uint32(message.validatorIndex);
    }
    if (message.balance !== undefined && message.balance !== BigInt("0")) {
      if (BigInt.asUintN(64, message.balance) !== message.balance) {
        throw new globalThis.Error("value provided for field message.balance of type uint64 too large");
      }
      writer.uint32(16).uint64(message.balance.toString());
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.pubkey !== undefined) {
      B384.encode(message.pubkey, writer.uint32(34).fork()).ldelim();
    }
    if (message.withdrawalCredentials !== undefined) {
      B256.encode(message.withdrawalCredentials, writer.uint32(42).fork()).ldelim();
    }
    if (message.effectiveBalance !== undefined && message.effectiveBalance !== BigInt("0")) {
      if (BigInt.asUintN(64, message.effectiveBalance) !== message.effectiveBalance) {
        throw new globalThis.Error("value provided for field message.effectiveBalance of type uint64 too large");
      }
      writer.uint32(48).uint64(message.effectiveBalance.toString());
    }
    if (message.slashed !== undefined && message.slashed !== false) {
      writer.uint32(56).bool(message.slashed);
    }
    if (message.activationEligibilityEpoch !== undefined && message.activationEligibilityEpoch !== BigInt("0")) {
      if (BigInt.asUintN(64, message.activationEligibilityEpoch) !== message.activationEligibilityEpoch) {
        throw new globalThis.Error(
          "value provided for field message.activationEligibilityEpoch of type uint64 too large",
        );
      }
      writer.uint32(64).uint64(message.activationEligibilityEpoch.toString());
    }
    if (message.activationEpoch !== undefined && message.activationEpoch !== BigInt("0")) {
      if (BigInt.asUintN(64, message.activationEpoch) !== message.activationEpoch) {
        throw new globalThis.Error("value provided for field message.activationEpoch of type uint64 too large");
      }
      writer.uint32(72).uint64(message.activationEpoch.toString());
    }
    if (message.exitEpoch !== undefined && message.exitEpoch !== BigInt("0")) {
      if (BigInt.asUintN(64, message.exitEpoch) !== message.exitEpoch) {
        throw new globalThis.Error("value provided for field message.exitEpoch of type uint64 too large");
      }
      writer.uint32(80).uint64(message.exitEpoch.toString());
    }
    if (message.withdrawableEpoch !== undefined && message.withdrawableEpoch !== BigInt("0")) {
      if (BigInt.asUintN(64, message.withdrawableEpoch) !== message.withdrawableEpoch) {
        throw new globalThis.Error("value provided for field message.withdrawableEpoch of type uint64 too large");
      }
      writer.uint32(88).uint64(message.withdrawableEpoch.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Validator {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidator() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.validatorIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.balance = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pubkey = B384.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.withdrawalCredentials = B256.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.effectiveBalance = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.slashed = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.activationEligibilityEpoch = longToBigint(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.activationEpoch = longToBigint(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.exitEpoch = longToBigint(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.withdrawableEpoch = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Validator {
    return {
      validatorIndex: isSet(object.validatorIndex) ? globalThis.Number(object.validatorIndex) : 0,
      balance: isSet(object.balance) ? BigInt(object.balance) : BigInt("0"),
      status: isSet(object.status) ? validatorStatusFromJSON(object.status) : 0,
      pubkey: isSet(object.pubkey) ? B384.fromJSON(object.pubkey) : undefined,
      withdrawalCredentials: isSet(object.withdrawalCredentials)
        ? B256.fromJSON(object.withdrawalCredentials)
        : undefined,
      effectiveBalance: isSet(object.effectiveBalance) ? BigInt(object.effectiveBalance) : BigInt("0"),
      slashed: isSet(object.slashed) ? globalThis.Boolean(object.slashed) : false,
      activationEligibilityEpoch: isSet(object.activationEligibilityEpoch)
        ? BigInt(object.activationEligibilityEpoch)
        : BigInt("0"),
      activationEpoch: isSet(object.activationEpoch) ? BigInt(object.activationEpoch) : BigInt("0"),
      exitEpoch: isSet(object.exitEpoch) ? BigInt(object.exitEpoch) : BigInt("0"),
      withdrawableEpoch: isSet(object.withdrawableEpoch) ? BigInt(object.withdrawableEpoch) : BigInt("0"),
    };
  },

  toJSON(message: Validator): unknown {
    const obj: any = {};
    if (message.validatorIndex !== undefined && message.validatorIndex !== 0) {
      obj.validatorIndex = Math.round(message.validatorIndex);
    }
    if (message.balance !== undefined && message.balance !== BigInt("0")) {
      obj.balance = message.balance.toString();
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = validatorStatusToJSON(message.status);
    }
    if (message.pubkey !== undefined) {
      obj.pubkey = B384.toJSON(message.pubkey);
    }
    if (message.withdrawalCredentials !== undefined) {
      obj.withdrawalCredentials = B256.toJSON(message.withdrawalCredentials);
    }
    if (message.effectiveBalance !== undefined && message.effectiveBalance !== BigInt("0")) {
      obj.effectiveBalance = message.effectiveBalance.toString();
    }
    if (message.slashed !== undefined && message.slashed !== false) {
      obj.slashed = message.slashed;
    }
    if (message.activationEligibilityEpoch !== undefined && message.activationEligibilityEpoch !== BigInt("0")) {
      obj.activationEligibilityEpoch = message.activationEligibilityEpoch.toString();
    }
    if (message.activationEpoch !== undefined && message.activationEpoch !== BigInt("0")) {
      obj.activationEpoch = message.activationEpoch.toString();
    }
    if (message.exitEpoch !== undefined && message.exitEpoch !== BigInt("0")) {
      obj.exitEpoch = message.exitEpoch.toString();
    }
    if (message.withdrawableEpoch !== undefined && message.withdrawableEpoch !== BigInt("0")) {
      obj.withdrawableEpoch = message.withdrawableEpoch.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Validator>): Validator {
    return Validator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Validator>): Validator {
    const message = createBaseValidator() as any;
    message.validatorIndex = object.validatorIndex ?? 0;
    message.balance = object.balance ?? BigInt("0");
    message.status = object.status ?? 0;
    message.pubkey = (object.pubkey !== undefined && object.pubkey !== null)
      ? B384.fromPartial(object.pubkey)
      : undefined;
    message.withdrawalCredentials =
      (object.withdrawalCredentials !== undefined && object.withdrawalCredentials !== null)
        ? B256.fromPartial(object.withdrawalCredentials)
        : undefined;
    message.effectiveBalance = object.effectiveBalance ?? BigInt("0");
    message.slashed = object.slashed ?? false;
    message.activationEligibilityEpoch = object.activationEligibilityEpoch ?? BigInt("0");
    message.activationEpoch = object.activationEpoch ?? BigInt("0");
    message.exitEpoch = object.exitEpoch ?? BigInt("0");
    message.withdrawableEpoch = object.withdrawableEpoch ?? BigInt("0");
    return message;
  },
};

function createBaseBlob(): Blob {
  return {
    blobIndex: 0,
    blob: new Uint8Array(0),
    kzgCommitment: undefined,
    kzgProof: undefined,
    kzgCommitmentInclusionProof: [],
    blobHash: undefined,
  };
}

export const Blob = {
  encode(message: Blob, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blobIndex !== undefined && message.blobIndex !== 0) {
      writer.uint32(8).uint32(message.blobIndex);
    }
    if (message.blob !== undefined && message.blob.length !== 0) {
      writer.uint32(18).bytes(message.blob);
    }
    if (message.kzgCommitment !== undefined) {
      B384.encode(message.kzgCommitment, writer.uint32(26).fork()).ldelim();
    }
    if (message.kzgProof !== undefined) {
      B384.encode(message.kzgProof, writer.uint32(34).fork()).ldelim();
    }
    if (message.kzgCommitmentInclusionProof !== undefined && message.kzgCommitmentInclusionProof.length !== 0) {
      for (const v of message.kzgCommitmentInclusionProof) {
        B256.encode(v!, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.blobHash !== undefined) {
      B256.encode(message.blobHash, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Blob {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlob() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.blobIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blob = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kzgCommitment = B384.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kzgProof = B384.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kzgCommitmentInclusionProof!.push(B256.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blobHash = B256.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blob {
    return {
      blobIndex: isSet(object.blobIndex) ? globalThis.Number(object.blobIndex) : 0,
      blob: isSet(object.blob) ? bytesFromBase64(object.blob) : new Uint8Array(0),
      kzgCommitment: isSet(object.kzgCommitment) ? B384.fromJSON(object.kzgCommitment) : undefined,
      kzgProof: isSet(object.kzgProof) ? B384.fromJSON(object.kzgProof) : undefined,
      kzgCommitmentInclusionProof: globalThis.Array.isArray(object?.kzgCommitmentInclusionProof)
        ? object.kzgCommitmentInclusionProof.map((e: any) => B256.fromJSON(e))
        : [],
      blobHash: isSet(object.blobHash) ? B256.fromJSON(object.blobHash) : undefined,
    };
  },

  toJSON(message: Blob): unknown {
    const obj: any = {};
    if (message.blobIndex !== undefined && message.blobIndex !== 0) {
      obj.blobIndex = Math.round(message.blobIndex);
    }
    if (message.blob !== undefined && message.blob.length !== 0) {
      obj.blob = base64FromBytes(message.blob);
    }
    if (message.kzgCommitment !== undefined) {
      obj.kzgCommitment = B384.toJSON(message.kzgCommitment);
    }
    if (message.kzgProof !== undefined) {
      obj.kzgProof = B384.toJSON(message.kzgProof);
    }
    if (message.kzgCommitmentInclusionProof?.length) {
      obj.kzgCommitmentInclusionProof = message.kzgCommitmentInclusionProof.map((e) => B256.toJSON(e));
    }
    if (message.blobHash !== undefined) {
      obj.blobHash = B256.toJSON(message.blobHash);
    }
    return obj;
  },

  create(base?: DeepPartial<Blob>): Blob {
    return Blob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blob>): Blob {
    const message = createBaseBlob() as any;
    message.blobIndex = object.blobIndex ?? 0;
    message.blob = object.blob ?? new Uint8Array(0);
    message.kzgCommitment = (object.kzgCommitment !== undefined && object.kzgCommitment !== null)
      ? B384.fromPartial(object.kzgCommitment)
      : undefined;
    message.kzgProof = (object.kzgProof !== undefined && object.kzgProof !== null)
      ? B384.fromPartial(object.kzgProof)
      : undefined;
    message.kzgCommitmentInclusionProof = object.kzgCommitmentInclusionProof?.map((e) => B256.fromPartial(e)) || [];
    message.blobHash = (object.blobHash !== undefined && object.blobHash !== null)
      ? B256.fromPartial(object.blobHash)
      : undefined;
    return message;
  },
};

function createBaseExecutionPayload(): ExecutionPayload {
  return {
    parentHash: undefined,
    feeRecipient: undefined,
    stateRoot: undefined,
    receiptsRoot: undefined,
    logsBloom: new Uint8Array(0),
    prevRandao: undefined,
    blockNumber: BigInt("0"),
    timestamp: undefined,
  };
}

export const ExecutionPayload = {
  encode(message: ExecutionPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parentHash !== undefined) {
      B256.encode(message.parentHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.feeRecipient !== undefined) {
      Address.encode(message.feeRecipient, writer.uint32(18).fork()).ldelim();
    }
    if (message.stateRoot !== undefined) {
      B256.encode(message.stateRoot, writer.uint32(26).fork()).ldelim();
    }
    if (message.receiptsRoot !== undefined) {
      B256.encode(message.receiptsRoot, writer.uint32(34).fork()).ldelim();
    }
    if (message.logsBloom !== undefined && message.logsBloom.length !== 0) {
      writer.uint32(42).bytes(message.logsBloom);
    }
    if (message.prevRandao !== undefined) {
      B256.encode(message.prevRandao, writer.uint32(50).fork()).ldelim();
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      if (BigInt.asUintN(64, message.blockNumber) !== message.blockNumber) {
        throw new globalThis.Error("value provided for field message.blockNumber of type uint64 too large");
      }
      writer.uint32(56).uint64(message.blockNumber.toString());
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionPayload() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentHash = B256.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeRecipient = Address.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateRoot = B256.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.receiptsRoot = B256.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logsBloom = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.prevRandao = B256.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.blockNumber = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionPayload {
    return {
      parentHash: isSet(object.parentHash) ? B256.fromJSON(object.parentHash) : undefined,
      feeRecipient: isSet(object.feeRecipient) ? Address.fromJSON(object.feeRecipient) : undefined,
      stateRoot: isSet(object.stateRoot) ? B256.fromJSON(object.stateRoot) : undefined,
      receiptsRoot: isSet(object.receiptsRoot) ? B256.fromJSON(object.receiptsRoot) : undefined,
      logsBloom: isSet(object.logsBloom) ? bytesFromBase64(object.logsBloom) : new Uint8Array(0),
      prevRandao: isSet(object.prevRandao) ? B256.fromJSON(object.prevRandao) : undefined,
      blockNumber: isSet(object.blockNumber) ? BigInt(object.blockNumber) : BigInt("0"),
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: ExecutionPayload): unknown {
    const obj: any = {};
    if (message.parentHash !== undefined) {
      obj.parentHash = B256.toJSON(message.parentHash);
    }
    if (message.feeRecipient !== undefined) {
      obj.feeRecipient = Address.toJSON(message.feeRecipient);
    }
    if (message.stateRoot !== undefined) {
      obj.stateRoot = B256.toJSON(message.stateRoot);
    }
    if (message.receiptsRoot !== undefined) {
      obj.receiptsRoot = B256.toJSON(message.receiptsRoot);
    }
    if (message.logsBloom !== undefined && message.logsBloom.length !== 0) {
      obj.logsBloom = base64FromBytes(message.logsBloom);
    }
    if (message.prevRandao !== undefined) {
      obj.prevRandao = B256.toJSON(message.prevRandao);
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      obj.blockNumber = message.blockNumber.toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionPayload>): ExecutionPayload {
    return ExecutionPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionPayload>): ExecutionPayload {
    const message = createBaseExecutionPayload() as any;
    message.parentHash = (object.parentHash !== undefined && object.parentHash !== null)
      ? B256.fromPartial(object.parentHash)
      : undefined;
    message.feeRecipient = (object.feeRecipient !== undefined && object.feeRecipient !== null)
      ? Address.fromPartial(object.feeRecipient)
      : undefined;
    message.stateRoot = (object.stateRoot !== undefined && object.stateRoot !== null)
      ? B256.fromPartial(object.stateRoot)
      : undefined;
    message.receiptsRoot = (object.receiptsRoot !== undefined && object.receiptsRoot !== null)
      ? B256.fromPartial(object.receiptsRoot)
      : undefined;
    message.logsBloom = object.logsBloom ?? new Uint8Array(0);
    message.prevRandao = (object.prevRandao !== undefined && object.prevRandao !== null)
      ? B256.fromPartial(object.prevRandao)
      : undefined;
    message.blockNumber = object.blockNumber ?? BigInt("0");
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { r: undefined, s: undefined, v: undefined, yParity: false };
}

export const Signature = {
  encode(message: Signature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.r !== undefined) {
      U256.encode(message.r, writer.uint32(10).fork()).ldelim();
    }
    if (message.s !== undefined) {
      U256.encode(message.s, writer.uint32(18).fork()).ldelim();
    }
    if (message.v !== undefined) {
      U256.encode(message.v, writer.uint32(26).fork()).ldelim();
    }
    if (message.yParity !== undefined && message.yParity !== false) {
      writer.uint32(32).bool(message.yParity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Signature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.r = U256.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.s = U256.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.v = U256.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.yParity = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      r: isSet(object.r) ? U256.fromJSON(object.r) : undefined,
      s: isSet(object.s) ? U256.fromJSON(object.s) : undefined,
      v: isSet(object.v) ? U256.fromJSON(object.v) : undefined,
      yParity: isSet(object.yParity) ? globalThis.Boolean(object.yParity) : false,
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.r !== undefined) {
      obj.r = U256.toJSON(message.r);
    }
    if (message.s !== undefined) {
      obj.s = U256.toJSON(message.s);
    }
    if (message.v !== undefined) {
      obj.v = U256.toJSON(message.v);
    }
    if (message.yParity !== undefined && message.yParity !== false) {
      obj.yParity = message.yParity;
    }
    return obj;
  },

  create(base?: DeepPartial<Signature>): Signature {
    return Signature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Signature>): Signature {
    const message = createBaseSignature() as any;
    message.r = (object.r !== undefined && object.r !== null) ? U256.fromPartial(object.r) : undefined;
    message.s = (object.s !== undefined && object.s !== null) ? U256.fromPartial(object.s) : undefined;
    message.v = (object.v !== undefined && object.v !== null) ? U256.fromPartial(object.v) : undefined;
    message.yParity = object.yParity ?? false;
    return message;
  },
};

function createBaseAccessListItem(): AccessListItem {
  return { address: undefined, storageKeys: [] };
}

export const AccessListItem = {
  encode(message: AccessListItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).ldelim();
    }
    if (message.storageKeys !== undefined && message.storageKeys.length !== 0) {
      for (const v of message.storageKeys) {
        B256.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccessListItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessListItem() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storageKeys!.push(B256.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessListItem {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      storageKeys: globalThis.Array.isArray(object?.storageKeys)
        ? object.storageKeys.map((e: any) => B256.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccessListItem): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.storageKeys?.length) {
      obj.storageKeys = message.storageKeys.map((e) => B256.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccessListItem>): AccessListItem {
    return AccessListItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessListItem>): AccessListItem {
    const message = createBaseAccessListItem() as any;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.storageKeys = object.storageKeys?.map((e) => B256.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds?.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
