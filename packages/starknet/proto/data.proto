// Starknet DNA definitions (data).
syntax = "proto3";

package starknet.v2;

import "google/protobuf/timestamp.proto";
import "common.proto";

// Requested data, grouped by block.
message Block {
  // The header.
  BlockHeader header = 1;
  // List of transactions.
  repeated Transaction transactions = 2;
  // List of transactions receipts.
  repeated TransactionReceipt receipts = 3;
  // List of events.
  repeated Event events = 4;
}

// Block header.
message BlockHeader {
  // Hash of the block.
  FieldElement block_hash = 1;
  // Hash of the block's parent.
  FieldElement parent_block_hash = 2;
  // Block height.
  uint64 block_number = 3;
  // Sequencer address.
  FieldElement sequencer_address = 4;
  // New state root after the block.
  FieldElement new_root = 5;
  // Timestamp when block  was produced.
  google.protobuf.Timestamp timestamp = 6;
  // Starknet version.
  string starknet_version = 7;
  // Price of L1 gas in the block.
  ResourcePrice l1_gas_price = 8;
  // Price of L1 data gas in the block.
  ResourcePrice l1_data_gas_price = 9;
  // L1 data availability mode.
  L1DataAvailabilityMode l1_data_availability_mode = 10;
}

// A transaction.
message Transaction {
  // Common transaction metadata.
  TransactionMeta meta = 1;
  oneof transaction {
    // Transaction invoking a smart contract, V0.
    InvokeTransactionV0 invoke_v0 = 2;
    // Transaction invoking a smart contract, V1.
    InvokeTransactionV1 invoke_v1 = 3;
    // Transaction deploying a new smart contract, V1.
    DeployTransaction deploy = 4;
    // Transaction declaring a smart contract.
    DeclareTransaction declare = 5;
    // Transaction handling a message from L1.
    L1HandlerTransaction l1_handler = 6;
    // Transaction deploying a new account.
    DeployAccountTransaction deploy_account = 7;
    // Transaction deploying a new smart contract, V3.
    DeployAccountTransactionV3 deploy_account_v3 = 8;
    // Transaction invoking a smart contract, V3.
    InvokeTransactionV3 invoke_v3 = 9;
    // Transaction declaring a smart contract, V3.
    DeclareTransactionV3 declare_v3 = 10;
  }
}
// Common transaction metadata.
message TransactionMeta {
  // Transaction hash.
  FieldElement hash = 1;
  // Maximum fee to be paid.
  FieldElement max_fee = 2;
  // Signature by the user.
  repeated FieldElement signature = 3;
  // Nonce.
  FieldElement nonce = 4;
  // Version.
  uint64 version = 5;
  // Transaction resources.
  ResourceBoundsMapping resource_bounds = 6;
  // Tip to the sequencer.
  uint64 tip = 7;
  // Data passed to the paymaster.
  repeated FieldElement paymaster_data = 8;
  // The storage domain of the account's nonce.
  DataAvailabilityMode nonce_data_availability_mode = 9;
  // The storage domain of the account's balance from which fee will be charged.
  DataAvailabilityMode fee_data_availability_mode = 10;
  // Index of the transaction in the block.
  uint64 transaction_index = 11;
}

// Transaction invoking a smart contract, V0.
message InvokeTransactionV0 {
  // Target contract address.
  FieldElement contract_address = 1;
  // Selector of the function being invoked.
  FieldElement entry_point_selector = 2;
  // Raw calldata.
  repeated FieldElement calldata = 3;
}

// Transaction invoking a smart contract, V1.
message InvokeTransactionV1 {
  // Address sending the transaction.
  FieldElement sender_address = 1;
  // Raw calldata.
  repeated FieldElement calldata = 2;
}

// Transaction invoking a smart contract, V3.
message InvokeTransactionV3 {
  // Address sending the transaction.
  FieldElement sender_address = 1;
  // Raw calldata.
  repeated FieldElement calldata = 2;
  // Data passed to the account deployment.
  repeated FieldElement account_deployment_data = 3;
}

// Transaction deploying a new smart contract, V1.
message DeployTransaction {
  // Raw calldata passed to the constructor.
  repeated FieldElement constructor_calldata = 2;
  // Salt used when computing the contract's address.
  FieldElement contract_address_salt = 3;
  // Hash of the class being deployed.
  FieldElement class_hash = 4;
}

// Transaction declaring a smart contract.
message DeclareTransaction {
  // Class hash.
  FieldElement class_hash = 1;
  // Address of the account declaring the class.
  FieldElement sender_address = 2;
  // The hash of the cairo assembly resulting from the sierra compilation.
  FieldElement compiled_class_hash = 3;
}

// Transaction declaring a smart contract.
message DeclareTransactionV3 {
  // Class hash.
  FieldElement class_hash = 1;
  // Address of the account declaring the class.
  FieldElement sender_address = 2;
  // The hash of the cairo assembly resulting from the sierra compilation.
  FieldElement compiled_class_hash = 3;
  // Data passed to the account deployment.
  repeated FieldElement account_deployment_data = 4;
}

// Transaction handling a message from L1.
message L1HandlerTransaction {
  // Target contract address.
  FieldElement contract_address = 2;
  // Selector of the function being invoked.
  FieldElement entry_point_selector = 3;
  // Raw calldata.
  repeated FieldElement calldata = 4;
}

// Transaction deploying a new account.
message DeployAccountTransaction {
  // Raw calldata passed to the constructor.
  repeated FieldElement constructor_calldata = 2;
  // Salt used when computing the contract's address.
  FieldElement contract_address_salt = 3;
  // Hash of the class being deployed.
  FieldElement class_hash = 4;
}

// Transaction deploying a new smart contract, V3.
message DeployAccountTransactionV3 {
  // Raw calldata passed to the constructor.
  repeated FieldElement constructor_calldata = 1;
  // Salt used when computing the contract's address.
  FieldElement contract_address_salt = 2;
  // Hash of the class being deployed.
  FieldElement class_hash = 3;
}

// Transaction receipt.
message TransactionReceipt {}

// Transaction events.
message Event {}

enum L1DataAvailabilityMode {
  // Unknown DA.
  L1_DATA_AVAILABILITY_MODE_UNSPECIFIED = 0;
  // Data published via blobs.
  L1_DATA_AVAILABILITY_MODE_BLOB = 1;
  // Data published via calldata.
  L1_DATA_AVAILABILITY_MODE_CALLDATA = 2;
}

// Transaction execution status.
enum ExecutionStatus {
  // Unknown execution status.
  EXECUTION_STATUS_UNSPECIFIED = 0;
  // Transaction succeeded.
  EXECUTION_STATUS_SUCCEEDED = 1;
  // Transaction reverted.
  EXECUTION_STATUS_REVERTED = 2;
}

// Price of a unit of a resource.
message ResourcePrice {
  // Price in fri (10^-18 strk).
  FieldElement price_in_fri = 1;
  // Price in wei (10^-18 eth).
  FieldElement price_in_wei = 2;
}

// A Starknet fee payment.
message FeePayment {
  // Amount paid.
  FieldElement amount = 1;
  // Unit of the amount.
  PriceUnit unit = 2;
}

// Price unit.
enum PriceUnit {
  // Unknown price unit.
  PRICE_UNIT_UNSPECIFIED = 0;
  // WEI.
  PRICE_UNIT_WEI = 1;
  // FRI.
  PRICE_UNIT_FRI = 2;
}

// Execution resources.
message ExecutionResources {
  // Computation resources.
  ComputationResources computation = 1;
  // Data availability resources.
  DataAvailabilityResources data_availability = 2;
}

// Computation resources.
message ComputationResources {
  // The number of Cairo steps used.
  uint64 steps = 1;
  // The number of unused memory cells.
  uint64 memory_holes = 2;
  // The number of RANGE_CHECK builtin instances.
  uint64 range_check_builtin_applications = 3;
  // The number of Pedersen builtin instances.
  uint64 pedersen_builtin_applications = 4;
  // The number of Poseidon builtin instances.
  uint64 poseidon_builtin_applications = 5;
  // The number of EC_OP builtin instances.
  uint64 ec_op_builtin_applications = 6;
  // The number of ECDSA builtin instances.
  uint64 ecdsa_builtin_applications = 7;
  // The number of BITWISE builtin instances.
  uint64 bitwise_builtin_applications = 8;
  // The number of KECCAK builtin instances.
  uint64 keccak_builtin_applications = 9;
  // The number of accesses to the segment arena.
  uint64 segment_arena_builtin = 10;
}

message DataAvailabilityResources {
  // The gas consumed by this transaction's data, 0 if it uses data gas for DA.
  uint64 l1_gas = 1;
  // The data gas consumed by this transaction's data, 0 if it uses gas for DA.
  uint64 l1_data_gas = 2;
}

message ResourceBoundsMapping {
  // Maximum amount and price of L1 gas.
  ResourceBounds l1_gas = 1;
  // Maximum amount and price of L2 gas.
  ResourceBounds l2_gas = 2;
}

message ResourceBounds {
  // The maximum amount of resources that can be consumed by a transaction.
  uint64 max_amount = 1;
  /// The max price per unit of resource.
  Uint128 max_price_per_unit = 2;
}

message Uint128 {
  // The low 64 bits of the number.
  uint64 low = 1;
  // The high 64 bits of the number.
  uint64 high = 2;
}

// DA mode.
enum DataAvailabilityMode {
  // Unknown DA.
  DATA_AVAILABILITY_MODE_UNSPECIFIED = 0;
  // L1.
  DATA_AVAILABILITY_MODE_L1 = 1;
  // L2.
  DATA_AVAILABILITY_MODE_L2 = 2;
}
