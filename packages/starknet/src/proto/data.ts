// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: data.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { FieldElement } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "starknet.v2";

/** Starknet DNA definitions (data). */

export enum L1DataAvailabilityMode {
  /** L1_DATA_AVAILABILITY_MODE_UNSPECIFIED - Unknown DA. */
  L1_DATA_AVAILABILITY_MODE_UNSPECIFIED = 0,
  /** L1_DATA_AVAILABILITY_MODE_BLOB - Data published via blobs. */
  L1_DATA_AVAILABILITY_MODE_BLOB = 1,
  /** L1_DATA_AVAILABILITY_MODE_CALLDATA - Data published via calldata. */
  L1_DATA_AVAILABILITY_MODE_CALLDATA = 2,
  UNRECOGNIZED = -1,
}

export function l1DataAvailabilityModeFromJSON(object: any): L1DataAvailabilityMode {
  switch (object) {
    case 0:
    case "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_UNSPECIFIED;
    case 1:
    case "L1_DATA_AVAILABILITY_MODE_BLOB":
      return L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_BLOB;
    case 2:
    case "L1_DATA_AVAILABILITY_MODE_CALLDATA":
      return L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_CALLDATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return L1DataAvailabilityMode.UNRECOGNIZED;
  }
}

export function l1DataAvailabilityModeToJSON(object: L1DataAvailabilityMode): string {
  switch (object) {
    case L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_UNSPECIFIED:
      return "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_BLOB:
      return "L1_DATA_AVAILABILITY_MODE_BLOB";
    case L1DataAvailabilityMode.L1_DATA_AVAILABILITY_MODE_CALLDATA:
      return "L1_DATA_AVAILABILITY_MODE_CALLDATA";
    case L1DataAvailabilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction execution status. */
export enum ExecutionStatus {
  /** EXECUTION_STATUS_UNSPECIFIED - Unknown execution status. */
  EXECUTION_STATUS_UNSPECIFIED = 0,
  /** EXECUTION_STATUS_SUCCEEDED - Transaction succeeded. */
  EXECUTION_STATUS_SUCCEEDED = 1,
  /** EXECUTION_STATUS_REVERTED - Transaction reverted. */
  EXECUTION_STATUS_REVERTED = 2,
  UNRECOGNIZED = -1,
}

export function executionStatusFromJSON(object: any): ExecutionStatus {
  switch (object) {
    case 0:
    case "EXECUTION_STATUS_UNSPECIFIED":
      return ExecutionStatus.EXECUTION_STATUS_UNSPECIFIED;
    case 1:
    case "EXECUTION_STATUS_SUCCEEDED":
      return ExecutionStatus.EXECUTION_STATUS_SUCCEEDED;
    case 2:
    case "EXECUTION_STATUS_REVERTED":
      return ExecutionStatus.EXECUTION_STATUS_REVERTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionStatus.UNRECOGNIZED;
  }
}

export function executionStatusToJSON(object: ExecutionStatus): string {
  switch (object) {
    case ExecutionStatus.EXECUTION_STATUS_UNSPECIFIED:
      return "EXECUTION_STATUS_UNSPECIFIED";
    case ExecutionStatus.EXECUTION_STATUS_SUCCEEDED:
      return "EXECUTION_STATUS_SUCCEEDED";
    case ExecutionStatus.EXECUTION_STATUS_REVERTED:
      return "EXECUTION_STATUS_REVERTED";
    case ExecutionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Price unit. */
export enum PriceUnit {
  /** PRICE_UNIT_UNSPECIFIED - Unknown price unit. */
  PRICE_UNIT_UNSPECIFIED = 0,
  /** PRICE_UNIT_WEI - WEI. */
  PRICE_UNIT_WEI = 1,
  /** PRICE_UNIT_FRI - FRI. */
  PRICE_UNIT_FRI = 2,
  UNRECOGNIZED = -1,
}

export function priceUnitFromJSON(object: any): PriceUnit {
  switch (object) {
    case 0:
    case "PRICE_UNIT_UNSPECIFIED":
      return PriceUnit.PRICE_UNIT_UNSPECIFIED;
    case 1:
    case "PRICE_UNIT_WEI":
      return PriceUnit.PRICE_UNIT_WEI;
    case 2:
    case "PRICE_UNIT_FRI":
      return PriceUnit.PRICE_UNIT_FRI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PriceUnit.UNRECOGNIZED;
  }
}

export function priceUnitToJSON(object: PriceUnit): string {
  switch (object) {
    case PriceUnit.PRICE_UNIT_UNSPECIFIED:
      return "PRICE_UNIT_UNSPECIFIED";
    case PriceUnit.PRICE_UNIT_WEI:
      return "PRICE_UNIT_WEI";
    case PriceUnit.PRICE_UNIT_FRI:
      return "PRICE_UNIT_FRI";
    case PriceUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DA mode. */
export enum DataAvailabilityMode {
  /** DATA_AVAILABILITY_MODE_UNSPECIFIED - Unknown DA. */
  DATA_AVAILABILITY_MODE_UNSPECIFIED = 0,
  /** DATA_AVAILABILITY_MODE_L1 - L1. */
  DATA_AVAILABILITY_MODE_L1 = 1,
  /** DATA_AVAILABILITY_MODE_L2 - L2. */
  DATA_AVAILABILITY_MODE_L2 = 2,
  UNRECOGNIZED = -1,
}

export function dataAvailabilityModeFromJSON(object: any): DataAvailabilityMode {
  switch (object) {
    case 0:
    case "DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return DataAvailabilityMode.DATA_AVAILABILITY_MODE_UNSPECIFIED;
    case 1:
    case "DATA_AVAILABILITY_MODE_L1":
      return DataAvailabilityMode.DATA_AVAILABILITY_MODE_L1;
    case 2:
    case "DATA_AVAILABILITY_MODE_L2":
      return DataAvailabilityMode.DATA_AVAILABILITY_MODE_L2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataAvailabilityMode.UNRECOGNIZED;
  }
}

export function dataAvailabilityModeToJSON(object: DataAvailabilityMode): string {
  switch (object) {
    case DataAvailabilityMode.DATA_AVAILABILITY_MODE_UNSPECIFIED:
      return "DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case DataAvailabilityMode.DATA_AVAILABILITY_MODE_L1:
      return "DATA_AVAILABILITY_MODE_L1";
    case DataAvailabilityMode.DATA_AVAILABILITY_MODE_L2:
      return "DATA_AVAILABILITY_MODE_L2";
    case DataAvailabilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Requested data, grouped by block. */
export interface Block {
  /** The header. */
  readonly header?:
    | BlockHeader
    | undefined;
  /** List of transactions. */
  readonly transactions?:
    | readonly Transaction[]
    | undefined;
  /** List of transactions receipts. */
  readonly receipts?:
    | readonly TransactionReceipt[]
    | undefined;
  /** List of events. */
  readonly events?: readonly Event[] | undefined;
}

/** Block header. */
export interface BlockHeader {
  /** Hash of the block. */
  readonly blockHash?:
    | FieldElement
    | undefined;
  /** Hash of the block's parent. */
  readonly parentBlockHash?:
    | FieldElement
    | undefined;
  /** Block height. */
  readonly blockNumber?:
    | bigint
    | undefined;
  /** Sequencer address. */
  readonly sequencerAddress?:
    | FieldElement
    | undefined;
  /** New state root after the block. */
  readonly newRoot?:
    | FieldElement
    | undefined;
  /** Timestamp when block  was produced. */
  readonly timestamp?:
    | Date
    | undefined;
  /** Starknet version. */
  readonly starknetVersion?:
    | string
    | undefined;
  /** Price of L1 gas in the block. */
  readonly l1GasPrice?:
    | ResourcePrice
    | undefined;
  /** Price of L1 data gas in the block. */
  readonly l1DataGasPrice?:
    | ResourcePrice
    | undefined;
  /** L1 data availability mode. */
  readonly l1DataAvailabilityMode?: L1DataAvailabilityMode | undefined;
}

/** A transaction. */
export interface Transaction {
  /** Common transaction metadata. */
  readonly meta?: TransactionMeta | undefined;
  readonly transaction?:
    | { readonly $case: "invokeV0"; readonly invokeV0: InvokeTransactionV0 }
    | { readonly $case: "invokeV1"; readonly invokeV1: InvokeTransactionV1 }
    | { readonly $case: "deploy"; readonly deploy: DeployTransaction }
    | { readonly $case: "declare"; readonly declare: DeclareTransaction }
    | { readonly $case: "l1Handler"; readonly l1Handler: L1HandlerTransaction }
    | { readonly $case: "deployAccount"; readonly deployAccount: DeployAccountTransaction }
    | { readonly $case: "deployAccountV3"; readonly deployAccountV3: DeployAccountTransactionV3 }
    | { readonly $case: "invokeV3"; readonly invokeV3: InvokeTransactionV3 }
    | { readonly $case: "declareV3"; readonly declareV3: DeclareTransactionV3 }
    | undefined;
}

/** Common transaction metadata. */
export interface TransactionMeta {
  /** Transaction hash. */
  readonly hash?:
    | FieldElement
    | undefined;
  /** Maximum fee to be paid. */
  readonly maxFee?:
    | FieldElement
    | undefined;
  /** Signature by the user. */
  readonly signature?:
    | readonly FieldElement[]
    | undefined;
  /** Nonce. */
  readonly nonce?:
    | FieldElement
    | undefined;
  /** Version. */
  readonly version?:
    | bigint
    | undefined;
  /** Transaction resources. */
  readonly resourceBounds?:
    | ResourceBoundsMapping
    | undefined;
  /** Tip to the sequencer. */
  readonly tip?:
    | bigint
    | undefined;
  /** Data passed to the paymaster. */
  readonly paymasterData?:
    | readonly FieldElement[]
    | undefined;
  /** The storage domain of the account's nonce. */
  readonly nonceDataAvailabilityMode?:
    | DataAvailabilityMode
    | undefined;
  /** The storage domain of the account's balance from which fee will be charged. */
  readonly feeDataAvailabilityMode?:
    | DataAvailabilityMode
    | undefined;
  /** Index of the transaction in the block. */
  readonly transactionIndex?: bigint | undefined;
}

/** Transaction invoking a smart contract, V0. */
export interface InvokeTransactionV0 {
  /** Target contract address. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** Selector of the function being invoked. */
  readonly entryPointSelector?:
    | FieldElement
    | undefined;
  /** Raw calldata. */
  readonly calldata?: readonly FieldElement[] | undefined;
}

/** Transaction invoking a smart contract, V1. */
export interface InvokeTransactionV1 {
  /** Address sending the transaction. */
  readonly senderAddress?:
    | FieldElement
    | undefined;
  /** Raw calldata. */
  readonly calldata?: readonly FieldElement[] | undefined;
}

/** Transaction invoking a smart contract, V3. */
export interface InvokeTransactionV3 {
  /** Address sending the transaction. */
  readonly senderAddress?:
    | FieldElement
    | undefined;
  /** Raw calldata. */
  readonly calldata?:
    | readonly FieldElement[]
    | undefined;
  /** Data passed to the account deployment. */
  readonly accountDeploymentData?: readonly FieldElement[] | undefined;
}

/** Transaction deploying a new smart contract, V1. */
export interface DeployTransaction {
  /** Raw calldata passed to the constructor. */
  readonly constructorCalldata?:
    | readonly FieldElement[]
    | undefined;
  /** Salt used when computing the contract's address. */
  readonly contractAddressSalt?:
    | FieldElement
    | undefined;
  /** Hash of the class being deployed. */
  readonly classHash?: FieldElement | undefined;
}

/** Transaction declaring a smart contract. */
export interface DeclareTransaction {
  /** Class hash. */
  readonly classHash?:
    | FieldElement
    | undefined;
  /** Address of the account declaring the class. */
  readonly senderAddress?:
    | FieldElement
    | undefined;
  /** The hash of the cairo assembly resulting from the sierra compilation. */
  readonly compiledClassHash?: FieldElement | undefined;
}

/** Transaction declaring a smart contract. */
export interface DeclareTransactionV3 {
  /** Class hash. */
  readonly classHash?:
    | FieldElement
    | undefined;
  /** Address of the account declaring the class. */
  readonly senderAddress?:
    | FieldElement
    | undefined;
  /** The hash of the cairo assembly resulting from the sierra compilation. */
  readonly compiledClassHash?:
    | FieldElement
    | undefined;
  /** Data passed to the account deployment. */
  readonly accountDeploymentData?: readonly FieldElement[] | undefined;
}

/** Transaction handling a message from L1. */
export interface L1HandlerTransaction {
  /** Target contract address. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** Selector of the function being invoked. */
  readonly entryPointSelector?:
    | FieldElement
    | undefined;
  /** Raw calldata. */
  readonly calldata?: readonly FieldElement[] | undefined;
}

/** Transaction deploying a new account. */
export interface DeployAccountTransaction {
  /** Raw calldata passed to the constructor. */
  readonly constructorCalldata?:
    | readonly FieldElement[]
    | undefined;
  /** Salt used when computing the contract's address. */
  readonly contractAddressSalt?:
    | FieldElement
    | undefined;
  /** Hash of the class being deployed. */
  readonly classHash?: FieldElement | undefined;
}

/** Transaction deploying a new smart contract, V3. */
export interface DeployAccountTransactionV3 {
  /** Raw calldata passed to the constructor. */
  readonly constructorCalldata?:
    | readonly FieldElement[]
    | undefined;
  /** Salt used when computing the contract's address. */
  readonly contractAddressSalt?:
    | FieldElement
    | undefined;
  /** Hash of the class being deployed. */
  readonly classHash?: FieldElement | undefined;
}

/** Transaction receipt. */
export interface TransactionReceipt {
}

/** Transaction events. */
export interface Event {
}

/** Price of a unit of a resource. */
export interface ResourcePrice {
  /** Price in fri (10^-18 strk). */
  readonly priceInFri?:
    | FieldElement
    | undefined;
  /** Price in wei (10^-18 eth). */
  readonly priceInWei?: FieldElement | undefined;
}

/** A Starknet fee payment. */
export interface FeePayment {
  /** Amount paid. */
  readonly amount?:
    | FieldElement
    | undefined;
  /** Unit of the amount. */
  readonly unit?: PriceUnit | undefined;
}

/** Execution resources. */
export interface ExecutionResources {
  /** Computation resources. */
  readonly computation?:
    | ComputationResources
    | undefined;
  /** Data availability resources. */
  readonly dataAvailability?: DataAvailabilityResources | undefined;
}

/** Computation resources. */
export interface ComputationResources {
  /** The number of Cairo steps used. */
  readonly steps?:
    | bigint
    | undefined;
  /** The number of unused memory cells. */
  readonly memoryHoles?:
    | bigint
    | undefined;
  /** The number of RANGE_CHECK builtin instances. */
  readonly rangeCheckBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of Pedersen builtin instances. */
  readonly pedersenBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of Poseidon builtin instances. */
  readonly poseidonBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of EC_OP builtin instances. */
  readonly ecOpBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of ECDSA builtin instances. */
  readonly ecdsaBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of BITWISE builtin instances. */
  readonly bitwiseBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of KECCAK builtin instances. */
  readonly keccakBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of accesses to the segment arena. */
  readonly segmentArenaBuiltin?: bigint | undefined;
}

export interface DataAvailabilityResources {
  /** The gas consumed by this transaction's data, 0 if it uses data gas for DA. */
  readonly l1Gas?:
    | bigint
    | undefined;
  /** The data gas consumed by this transaction's data, 0 if it uses gas for DA. */
  readonly l1DataGas?: bigint | undefined;
}

export interface ResourceBoundsMapping {
  /** Maximum amount and price of L1 gas. */
  readonly l1Gas?:
    | ResourceBounds
    | undefined;
  /** Maximum amount and price of L2 gas. */
  readonly l2Gas?: ResourceBounds | undefined;
}

export interface ResourceBounds {
  /** The maximum amount of resources that can be consumed by a transaction. */
  readonly maxAmount?:
    | bigint
    | undefined;
  /** / The max price per unit of resource. */
  readonly maxPricePerUnit?: Uint128 | undefined;
}

export interface Uint128 {
  /** The low 64 bits of the number. */
  readonly low?:
    | bigint
    | undefined;
  /** The high 64 bits of the number. */
  readonly high?: bigint | undefined;
}

function createBaseBlock(): Block {
  return { header: undefined, transactions: [], receipts: [], events: [] };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactions !== undefined && message.transactions.length !== 0) {
      for (const v of message.transactions) {
        Transaction.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.receipts !== undefined && message.receipts.length !== 0) {
      for (const v of message.receipts) {
        TransactionReceipt.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.events !== undefined && message.events.length !== 0) {
      for (const v of message.events) {
        Event.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions!.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipts!.push(TransactionReceipt.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.events!.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      receipts: globalThis.Array.isArray(object?.receipts)
        ? object.receipts.map((e: any) => TransactionReceipt.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.receipts?.length) {
      obj.receipts = message.receipts.map((e) => TransactionReceipt.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock() as any;
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.receipts = object.receipts?.map((e) => TransactionReceipt.fromPartial(e)) || [];
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    blockHash: undefined,
    parentBlockHash: undefined,
    blockNumber: BigInt("0"),
    sequencerAddress: undefined,
    newRoot: undefined,
    timestamp: undefined,
    starknetVersion: "",
    l1GasPrice: undefined,
    l1DataGasPrice: undefined,
    l1DataAvailabilityMode: 0,
  };
}

export const BlockHeader = {
  encode(message: BlockHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== undefined) {
      FieldElement.encode(message.blockHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.parentBlockHash !== undefined) {
      FieldElement.encode(message.parentBlockHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      if (BigInt.asUintN(64, message.blockNumber) !== message.blockNumber) {
        throw new globalThis.Error("value provided for field message.blockNumber of type uint64 too large");
      }
      writer.uint32(24).uint64(message.blockNumber.toString());
    }
    if (message.sequencerAddress !== undefined) {
      FieldElement.encode(message.sequencerAddress, writer.uint32(34).fork()).ldelim();
    }
    if (message.newRoot !== undefined) {
      FieldElement.encode(message.newRoot, writer.uint32(42).fork()).ldelim();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      writer.uint32(58).string(message.starknetVersion);
    }
    if (message.l1GasPrice !== undefined) {
      ResourcePrice.encode(message.l1GasPrice, writer.uint32(66).fork()).ldelim();
    }
    if (message.l1DataGasPrice !== undefined) {
      ResourcePrice.encode(message.l1DataGasPrice, writer.uint32(74).fork()).ldelim();
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.l1DataAvailabilityMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentBlockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNumber = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sequencerAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newRoot = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.starknetVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.l1GasPrice = ResourcePrice.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.l1DataGasPrice = ResourcePrice.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.l1DataAvailabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      blockHash: isSet(object.blockHash) ? FieldElement.fromJSON(object.blockHash) : undefined,
      parentBlockHash: isSet(object.parentBlockHash) ? FieldElement.fromJSON(object.parentBlockHash) : undefined,
      blockNumber: isSet(object.blockNumber) ? BigInt(object.blockNumber) : BigInt("0"),
      sequencerAddress: isSet(object.sequencerAddress) ? FieldElement.fromJSON(object.sequencerAddress) : undefined,
      newRoot: isSet(object.newRoot) ? FieldElement.fromJSON(object.newRoot) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      starknetVersion: isSet(object.starknetVersion) ? globalThis.String(object.starknetVersion) : "",
      l1GasPrice: isSet(object.l1GasPrice) ? ResourcePrice.fromJSON(object.l1GasPrice) : undefined,
      l1DataGasPrice: isSet(object.l1DataGasPrice) ? ResourcePrice.fromJSON(object.l1DataGasPrice) : undefined,
      l1DataAvailabilityMode: isSet(object.l1DataAvailabilityMode)
        ? l1DataAvailabilityModeFromJSON(object.l1DataAvailabilityMode)
        : 0,
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.blockHash !== undefined) {
      obj.blockHash = FieldElement.toJSON(message.blockHash);
    }
    if (message.parentBlockHash !== undefined) {
      obj.parentBlockHash = FieldElement.toJSON(message.parentBlockHash);
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      obj.blockNumber = message.blockNumber.toString();
    }
    if (message.sequencerAddress !== undefined) {
      obj.sequencerAddress = FieldElement.toJSON(message.sequencerAddress);
    }
    if (message.newRoot !== undefined) {
      obj.newRoot = FieldElement.toJSON(message.newRoot);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      obj.starknetVersion = message.starknetVersion;
    }
    if (message.l1GasPrice !== undefined) {
      obj.l1GasPrice = ResourcePrice.toJSON(message.l1GasPrice);
    }
    if (message.l1DataGasPrice !== undefined) {
      obj.l1DataGasPrice = ResourcePrice.toJSON(message.l1DataGasPrice);
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      obj.l1DataAvailabilityMode = l1DataAvailabilityModeToJSON(message.l1DataAvailabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeader>): BlockHeader {
    return BlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeader>): BlockHeader {
    const message = createBaseBlockHeader() as any;
    message.blockHash = (object.blockHash !== undefined && object.blockHash !== null)
      ? FieldElement.fromPartial(object.blockHash)
      : undefined;
    message.parentBlockHash = (object.parentBlockHash !== undefined && object.parentBlockHash !== null)
      ? FieldElement.fromPartial(object.parentBlockHash)
      : undefined;
    message.blockNumber = object.blockNumber ?? BigInt("0");
    message.sequencerAddress = (object.sequencerAddress !== undefined && object.sequencerAddress !== null)
      ? FieldElement.fromPartial(object.sequencerAddress)
      : undefined;
    message.newRoot = (object.newRoot !== undefined && object.newRoot !== null)
      ? FieldElement.fromPartial(object.newRoot)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.starknetVersion = object.starknetVersion ?? "";
    message.l1GasPrice = (object.l1GasPrice !== undefined && object.l1GasPrice !== null)
      ? ResourcePrice.fromPartial(object.l1GasPrice)
      : undefined;
    message.l1DataGasPrice = (object.l1DataGasPrice !== undefined && object.l1DataGasPrice !== null)
      ? ResourcePrice.fromPartial(object.l1DataGasPrice)
      : undefined;
    message.l1DataAvailabilityMode = object.l1DataAvailabilityMode ?? 0;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { meta: undefined, transaction: undefined };
}

export const Transaction = {
  encode(message: Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.meta !== undefined) {
      TransactionMeta.encode(message.meta, writer.uint32(10).fork()).ldelim();
    }
    switch (message.transaction?.$case) {
      case "invokeV0":
        InvokeTransactionV0.encode(message.transaction.invokeV0, writer.uint32(18).fork()).ldelim();
        break;
      case "invokeV1":
        InvokeTransactionV1.encode(message.transaction.invokeV1, writer.uint32(26).fork()).ldelim();
        break;
      case "deploy":
        DeployTransaction.encode(message.transaction.deploy, writer.uint32(34).fork()).ldelim();
        break;
      case "declare":
        DeclareTransaction.encode(message.transaction.declare, writer.uint32(42).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransaction.encode(message.transaction.l1Handler, writer.uint32(50).fork()).ldelim();
        break;
      case "deployAccount":
        DeployAccountTransaction.encode(message.transaction.deployAccount, writer.uint32(58).fork()).ldelim();
        break;
      case "deployAccountV3":
        DeployAccountTransactionV3.encode(message.transaction.deployAccountV3, writer.uint32(66).fork()).ldelim();
        break;
      case "invokeV3":
        InvokeTransactionV3.encode(message.transaction.invokeV3, writer.uint32(74).fork()).ldelim();
        break;
      case "declareV3":
        DeclareTransactionV3.encode(message.transaction.declareV3, writer.uint32(82).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.meta = TransactionMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = { $case: "invokeV0", invokeV0: InvokeTransactionV0.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transaction = { $case: "invokeV1", invokeV1: InvokeTransactionV1.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transaction = { $case: "deploy", deploy: DeployTransaction.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transaction = { $case: "declare", declare: DeclareTransaction.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transaction = { $case: "l1Handler", l1Handler: L1HandlerTransaction.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transaction = {
            $case: "deployAccount",
            deployAccount: DeployAccountTransaction.decode(reader, reader.uint32()),
          };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transaction = {
            $case: "deployAccountV3",
            deployAccountV3: DeployAccountTransactionV3.decode(reader, reader.uint32()),
          };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transaction = { $case: "invokeV3", invokeV3: InvokeTransactionV3.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transaction = { $case: "declareV3", declareV3: DeclareTransactionV3.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      meta: isSet(object.meta) ? TransactionMeta.fromJSON(object.meta) : undefined,
      transaction: isSet(object.invokeV0)
        ? { $case: "invokeV0", invokeV0: InvokeTransactionV0.fromJSON(object.invokeV0) }
        : isSet(object.invokeV1)
        ? { $case: "invokeV1", invokeV1: InvokeTransactionV1.fromJSON(object.invokeV1) }
        : isSet(object.deploy)
        ? { $case: "deploy", deploy: DeployTransaction.fromJSON(object.deploy) }
        : isSet(object.declare)
        ? { $case: "declare", declare: DeclareTransaction.fromJSON(object.declare) }
        : isSet(object.l1Handler)
        ? { $case: "l1Handler", l1Handler: L1HandlerTransaction.fromJSON(object.l1Handler) }
        : isSet(object.deployAccount)
        ? { $case: "deployAccount", deployAccount: DeployAccountTransaction.fromJSON(object.deployAccount) }
        : isSet(object.deployAccountV3)
        ? { $case: "deployAccountV3", deployAccountV3: DeployAccountTransactionV3.fromJSON(object.deployAccountV3) }
        : isSet(object.invokeV3)
        ? { $case: "invokeV3", invokeV3: InvokeTransactionV3.fromJSON(object.invokeV3) }
        : isSet(object.declareV3)
        ? { $case: "declareV3", declareV3: DeclareTransactionV3.fromJSON(object.declareV3) }
        : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = TransactionMeta.toJSON(message.meta);
    }
    if (message.transaction?.$case === "invokeV0") {
      obj.invokeV0 = InvokeTransactionV0.toJSON(message.transaction.invokeV0);
    }
    if (message.transaction?.$case === "invokeV1") {
      obj.invokeV1 = InvokeTransactionV1.toJSON(message.transaction.invokeV1);
    }
    if (message.transaction?.$case === "deploy") {
      obj.deploy = DeployTransaction.toJSON(message.transaction.deploy);
    }
    if (message.transaction?.$case === "declare") {
      obj.declare = DeclareTransaction.toJSON(message.transaction.declare);
    }
    if (message.transaction?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransaction.toJSON(message.transaction.l1Handler);
    }
    if (message.transaction?.$case === "deployAccount") {
      obj.deployAccount = DeployAccountTransaction.toJSON(message.transaction.deployAccount);
    }
    if (message.transaction?.$case === "deployAccountV3") {
      obj.deployAccountV3 = DeployAccountTransactionV3.toJSON(message.transaction.deployAccountV3);
    }
    if (message.transaction?.$case === "invokeV3") {
      obj.invokeV3 = InvokeTransactionV3.toJSON(message.transaction.invokeV3);
    }
    if (message.transaction?.$case === "declareV3") {
      obj.declareV3 = DeclareTransactionV3.toJSON(message.transaction.declareV3);
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction() as any;
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? TransactionMeta.fromPartial(object.meta)
      : undefined;
    if (
      object.transaction?.$case === "invokeV0" &&
      object.transaction?.invokeV0 !== undefined &&
      object.transaction?.invokeV0 !== null
    ) {
      message.transaction = {
        $case: "invokeV0",
        invokeV0: InvokeTransactionV0.fromPartial(object.transaction.invokeV0),
      };
    }
    if (
      object.transaction?.$case === "invokeV1" &&
      object.transaction?.invokeV1 !== undefined &&
      object.transaction?.invokeV1 !== null
    ) {
      message.transaction = {
        $case: "invokeV1",
        invokeV1: InvokeTransactionV1.fromPartial(object.transaction.invokeV1),
      };
    }
    if (
      object.transaction?.$case === "deploy" &&
      object.transaction?.deploy !== undefined &&
      object.transaction?.deploy !== null
    ) {
      message.transaction = { $case: "deploy", deploy: DeployTransaction.fromPartial(object.transaction.deploy) };
    }
    if (
      object.transaction?.$case === "declare" &&
      object.transaction?.declare !== undefined &&
      object.transaction?.declare !== null
    ) {
      message.transaction = { $case: "declare", declare: DeclareTransaction.fromPartial(object.transaction.declare) };
    }
    if (
      object.transaction?.$case === "l1Handler" &&
      object.transaction?.l1Handler !== undefined &&
      object.transaction?.l1Handler !== null
    ) {
      message.transaction = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransaction.fromPartial(object.transaction.l1Handler),
      };
    }
    if (
      object.transaction?.$case === "deployAccount" &&
      object.transaction?.deployAccount !== undefined &&
      object.transaction?.deployAccount !== null
    ) {
      message.transaction = {
        $case: "deployAccount",
        deployAccount: DeployAccountTransaction.fromPartial(object.transaction.deployAccount),
      };
    }
    if (
      object.transaction?.$case === "deployAccountV3" &&
      object.transaction?.deployAccountV3 !== undefined &&
      object.transaction?.deployAccountV3 !== null
    ) {
      message.transaction = {
        $case: "deployAccountV3",
        deployAccountV3: DeployAccountTransactionV3.fromPartial(object.transaction.deployAccountV3),
      };
    }
    if (
      object.transaction?.$case === "invokeV3" &&
      object.transaction?.invokeV3 !== undefined &&
      object.transaction?.invokeV3 !== null
    ) {
      message.transaction = {
        $case: "invokeV3",
        invokeV3: InvokeTransactionV3.fromPartial(object.transaction.invokeV3),
      };
    }
    if (
      object.transaction?.$case === "declareV3" &&
      object.transaction?.declareV3 !== undefined &&
      object.transaction?.declareV3 !== null
    ) {
      message.transaction = {
        $case: "declareV3",
        declareV3: DeclareTransactionV3.fromPartial(object.transaction.declareV3),
      };
    }
    return message;
  },
};

function createBaseTransactionMeta(): TransactionMeta {
  return {
    hash: undefined,
    maxFee: undefined,
    signature: [],
    nonce: undefined,
    version: BigInt("0"),
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0,
    transactionIndex: BigInt("0"),
  };
}

export const TransactionMeta = {
  encode(message: TransactionMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined) {
      FieldElement.encode(message.hash, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.version !== undefined && message.version !== BigInt("0")) {
      if (BigInt.asUintN(64, message.version) !== message.version) {
        throw new globalThis.Error("value provided for field message.version of type uint64 too large");
      }
      writer.uint32(40).uint64(message.version.toString());
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping.encode(message.resourceBounds, writer.uint32(50).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(56).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(72).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.feeDataAvailabilityMode);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== BigInt("0")) {
      if (BigInt.asUintN(64, message.transactionIndex) !== message.transactionIndex) {
        throw new globalThis.Error("value provided for field message.transactionIndex of type uint64 too large");
      }
      writer.uint32(88).uint64(message.transactionIndex.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionMeta {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionMeta() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = longToBigint(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resourceBounds = ResourceBoundsMapping.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.tip = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.paymasterData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.nonceDataAvailabilityMode = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.feeDataAvailabilityMode = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.transactionIndex = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionMeta {
    return {
      hash: isSet(object.hash) ? FieldElement.fromJSON(object.hash) : undefined,
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      version: isSet(object.version) ? BigInt(object.version) : BigInt("0"),
      resourceBounds: isSet(object.resourceBounds) ? ResourceBoundsMapping.fromJSON(object.resourceBounds) : undefined,
      tip: isSet(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData)
        ? object.paymasterData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonceDataAvailabilityMode: isSet(object.nonceDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode)
        : 0,
      feeDataAvailabilityMode: isSet(object.feeDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode)
        : 0,
      transactionIndex: isSet(object.transactionIndex) ? BigInt(object.transactionIndex) : BigInt("0"),
    };
  },

  toJSON(message: TransactionMeta): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = FieldElement.toJSON(message.hash);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.version !== undefined && message.version !== BigInt("0")) {
      obj.version = message.version.toString();
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== BigInt("0")) {
      obj.transactionIndex = message.transactionIndex.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionMeta>): TransactionMeta {
    return TransactionMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionMeta>): TransactionMeta {
    const message = createBaseTransactionMeta() as any;
    message.hash = (object.hash !== undefined && object.hash !== null)
      ? FieldElement.fromPartial(object.hash)
      : undefined;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.version = object.version ?? BigInt("0");
    message.resourceBounds = (object.resourceBounds !== undefined && object.resourceBounds !== null)
      ? ResourceBoundsMapping.fromPartial(object.resourceBounds)
      : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    message.transactionIndex = object.transactionIndex ?? BigInt("0");
    return message;
  },
};

function createBaseInvokeTransactionV0(): InvokeTransactionV0 {
  return { contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}

export const InvokeTransactionV0 = {
  encode(message: InvokeTransactionV0, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(18).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV0 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV0() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV0 {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InvokeTransactionV0): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV0>): InvokeTransactionV0 {
    return InvokeTransactionV0.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV0>): InvokeTransactionV0 {
    const message = createBaseInvokeTransactionV0() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvokeTransactionV1(): InvokeTransactionV1 {
  return { senderAddress: undefined, calldata: [] };
}

export const InvokeTransactionV1 = {
  encode(message: InvokeTransactionV1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV1() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV1 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InvokeTransactionV1): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV1>): InvokeTransactionV1 {
    return InvokeTransactionV1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV1>): InvokeTransactionV1 {
    const message = createBaseInvokeTransactionV1() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvokeTransactionV3(): InvokeTransactionV3 {
  return { senderAddress: undefined, calldata: [], accountDeploymentData: [] };
}

export const InvokeTransactionV3 = {
  encode(message: InvokeTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountDeploymentData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV3 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData)
        ? object.accountDeploymentData.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InvokeTransactionV3): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV3>): InvokeTransactionV3 {
    return InvokeTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV3>): InvokeTransactionV3 {
    const message = createBaseInvokeTransactionV3() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployTransaction(): DeployTransaction {
  return { constructorCalldata: [], contractAddressSalt: undefined, classHash: undefined };
}

export const DeployTransaction = {
  encode(message: DeployTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(26).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployTransaction {
    return {
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployTransaction): unknown {
    const obj: any = {};
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployTransaction>): DeployTransaction {
    return DeployTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployTransaction>): DeployTransaction {
    const message = createBaseDeployTransaction() as any;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransaction(): DeclareTransaction {
  return { classHash: undefined, senderAddress: undefined, compiledClassHash: undefined };
}

export const DeclareTransaction = {
  encode(message: DeclareTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransaction {
    return {
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
    };
  },

  toJSON(message: DeclareTransaction): unknown {
    const obj: any = {};
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransaction>): DeclareTransaction {
    return DeclareTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransaction>): DeclareTransaction {
    const message = createBaseDeclareTransaction() as any;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.compiledClassHash = (object.compiledClassHash !== undefined && object.compiledClassHash !== null)
      ? FieldElement.fromPartial(object.compiledClassHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransactionV3(): DeclareTransactionV3 {
  return { classHash: undefined, senderAddress: undefined, compiledClassHash: undefined, accountDeploymentData: [] };
}

export const DeclareTransactionV3 = {
  encode(message: DeclareTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(26).fork()).ldelim();
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountDeploymentData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionV3 {
    return {
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData)
        ? object.accountDeploymentData.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeclareTransactionV3): unknown {
    const obj: any = {};
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionV3>): DeclareTransactionV3 {
    return DeclareTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionV3>): DeclareTransactionV3 {
    const message = createBaseDeclareTransactionV3() as any;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.compiledClassHash = (object.compiledClassHash !== undefined && object.compiledClassHash !== null)
      ? FieldElement.fromPartial(object.compiledClassHash)
      : undefined;
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseL1HandlerTransaction(): L1HandlerTransaction {
  return { contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}

export const L1HandlerTransaction = {
  encode(message: L1HandlerTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(26).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): L1HandlerTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): L1HandlerTransaction {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: L1HandlerTransaction): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<L1HandlerTransaction>): L1HandlerTransaction {
    return L1HandlerTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<L1HandlerTransaction>): L1HandlerTransaction {
    const message = createBaseL1HandlerTransaction() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployAccountTransaction(): DeployAccountTransaction {
  return { constructorCalldata: [], contractAddressSalt: undefined, classHash: undefined };
}

export const DeployAccountTransaction = {
  encode(message: DeployAccountTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(26).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransaction {
    return {
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployAccountTransaction): unknown {
    const obj: any = {};
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransaction>): DeployAccountTransaction {
    return DeployAccountTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransaction>): DeployAccountTransaction {
    const message = createBaseDeployAccountTransaction() as any;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeployAccountTransactionV3(): DeployAccountTransactionV3 {
  return { constructorCalldata: [], contractAddressSalt: undefined, classHash: undefined };
}

export const DeployAccountTransactionV3 = {
  encode(message: DeployAccountTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(10).fork()).ldelim();
      }
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(18).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransactionV3 {
    return {
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployAccountTransactionV3): unknown {
    const obj: any = {};
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransactionV3>): DeployAccountTransactionV3 {
    return DeployAccountTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransactionV3>): DeployAccountTransactionV3 {
    const message = createBaseDeployAccountTransactionV3() as any;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseTransactionReceipt(): TransactionReceipt {
  return {};
}

export const TransactionReceipt = {
  encode(_: TransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TransactionReceipt {
    return {};
  },

  toJSON(_: TransactionReceipt): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TransactionReceipt>): TransactionReceipt {
    return TransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TransactionReceipt>): TransactionReceipt {
    const message = createBaseTransactionReceipt() as any;
    return message;
  },
};

function createBaseEvent(): Event {
  return {};
}

export const Event = {
  encode(_: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Event {
    return {};
  },

  toJSON(_: Event): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Event>): Event {
    const message = createBaseEvent() as any;
    return message;
  },
};

function createBaseResourcePrice(): ResourcePrice {
  return { priceInFri: undefined, priceInWei: undefined };
}

export const ResourcePrice = {
  encode(message: ResourcePrice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceInFri !== undefined) {
      FieldElement.encode(message.priceInFri, writer.uint32(10).fork()).ldelim();
    }
    if (message.priceInWei !== undefined) {
      FieldElement.encode(message.priceInWei, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourcePrice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePrice() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.priceInFri = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.priceInWei = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcePrice {
    return {
      priceInFri: isSet(object.priceInFri) ? FieldElement.fromJSON(object.priceInFri) : undefined,
      priceInWei: isSet(object.priceInWei) ? FieldElement.fromJSON(object.priceInWei) : undefined,
    };
  },

  toJSON(message: ResourcePrice): unknown {
    const obj: any = {};
    if (message.priceInFri !== undefined) {
      obj.priceInFri = FieldElement.toJSON(message.priceInFri);
    }
    if (message.priceInWei !== undefined) {
      obj.priceInWei = FieldElement.toJSON(message.priceInWei);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourcePrice>): ResourcePrice {
    return ResourcePrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourcePrice>): ResourcePrice {
    const message = createBaseResourcePrice() as any;
    message.priceInFri = (object.priceInFri !== undefined && object.priceInFri !== null)
      ? FieldElement.fromPartial(object.priceInFri)
      : undefined;
    message.priceInWei = (object.priceInWei !== undefined && object.priceInWei !== null)
      ? FieldElement.fromPartial(object.priceInWei)
      : undefined;
    return message;
  },
};

function createBaseFeePayment(): FeePayment {
  return { amount: undefined, unit: 0 };
}

export const FeePayment = {
  encode(message: FeePayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== undefined) {
      FieldElement.encode(message.amount, writer.uint32(10).fork()).ldelim();
    }
    if (message.unit !== undefined && message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeePayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePayment() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePayment {
    return {
      amount: isSet(object.amount) ? FieldElement.fromJSON(object.amount) : undefined,
      unit: isSet(object.unit) ? priceUnitFromJSON(object.unit) : 0,
    };
  },

  toJSON(message: FeePayment): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = FieldElement.toJSON(message.amount);
    }
    if (message.unit !== undefined && message.unit !== 0) {
      obj.unit = priceUnitToJSON(message.unit);
    }
    return obj;
  },

  create(base?: DeepPartial<FeePayment>): FeePayment {
    return FeePayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeePayment>): FeePayment {
    const message = createBaseFeePayment() as any;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? FieldElement.fromPartial(object.amount)
      : undefined;
    message.unit = object.unit ?? 0;
    return message;
  },
};

function createBaseExecutionResources(): ExecutionResources {
  return { computation: undefined, dataAvailability: undefined };
}

export const ExecutionResources = {
  encode(message: ExecutionResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.computation !== undefined) {
      ComputationResources.encode(message.computation, writer.uint32(10).fork()).ldelim();
    }
    if (message.dataAvailability !== undefined) {
      DataAvailabilityResources.encode(message.dataAvailability, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.computation = ComputationResources.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataAvailability = DataAvailabilityResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResources {
    return {
      computation: isSet(object.computation) ? ComputationResources.fromJSON(object.computation) : undefined,
      dataAvailability: isSet(object.dataAvailability)
        ? DataAvailabilityResources.fromJSON(object.dataAvailability)
        : undefined,
    };
  },

  toJSON(message: ExecutionResources): unknown {
    const obj: any = {};
    if (message.computation !== undefined) {
      obj.computation = ComputationResources.toJSON(message.computation);
    }
    if (message.dataAvailability !== undefined) {
      obj.dataAvailability = DataAvailabilityResources.toJSON(message.dataAvailability);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionResources>): ExecutionResources {
    return ExecutionResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionResources>): ExecutionResources {
    const message = createBaseExecutionResources() as any;
    message.computation = (object.computation !== undefined && object.computation !== null)
      ? ComputationResources.fromPartial(object.computation)
      : undefined;
    message.dataAvailability = (object.dataAvailability !== undefined && object.dataAvailability !== null)
      ? DataAvailabilityResources.fromPartial(object.dataAvailability)
      : undefined;
    return message;
  },
};

function createBaseComputationResources(): ComputationResources {
  return {
    steps: BigInt("0"),
    memoryHoles: BigInt("0"),
    rangeCheckBuiltinApplications: BigInt("0"),
    pedersenBuiltinApplications: BigInt("0"),
    poseidonBuiltinApplications: BigInt("0"),
    ecOpBuiltinApplications: BigInt("0"),
    ecdsaBuiltinApplications: BigInt("0"),
    bitwiseBuiltinApplications: BigInt("0"),
    keccakBuiltinApplications: BigInt("0"),
    segmentArenaBuiltin: BigInt("0"),
  };
}

export const ComputationResources = {
  encode(message: ComputationResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      if (BigInt.asUintN(64, message.steps) !== message.steps) {
        throw new globalThis.Error("value provided for field message.steps of type uint64 too large");
      }
      writer.uint32(8).uint64(message.steps.toString());
    }
    if (message.memoryHoles !== undefined && message.memoryHoles !== BigInt("0")) {
      if (BigInt.asUintN(64, message.memoryHoles) !== message.memoryHoles) {
        throw new globalThis.Error("value provided for field message.memoryHoles of type uint64 too large");
      }
      writer.uint32(16).uint64(message.memoryHoles.toString());
    }
    if (message.rangeCheckBuiltinApplications !== undefined && message.rangeCheckBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.rangeCheckBuiltinApplications) !== message.rangeCheckBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.rangeCheckBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(24).uint64(message.rangeCheckBuiltinApplications.toString());
    }
    if (message.pedersenBuiltinApplications !== undefined && message.pedersenBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.pedersenBuiltinApplications) !== message.pedersenBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.pedersenBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(32).uint64(message.pedersenBuiltinApplications.toString());
    }
    if (message.poseidonBuiltinApplications !== undefined && message.poseidonBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.poseidonBuiltinApplications) !== message.poseidonBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.poseidonBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(40).uint64(message.poseidonBuiltinApplications.toString());
    }
    if (message.ecOpBuiltinApplications !== undefined && message.ecOpBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.ecOpBuiltinApplications) !== message.ecOpBuiltinApplications) {
        throw new globalThis.Error("value provided for field message.ecOpBuiltinApplications of type uint64 too large");
      }
      writer.uint32(48).uint64(message.ecOpBuiltinApplications.toString());
    }
    if (message.ecdsaBuiltinApplications !== undefined && message.ecdsaBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.ecdsaBuiltinApplications) !== message.ecdsaBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.ecdsaBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(56).uint64(message.ecdsaBuiltinApplications.toString());
    }
    if (message.bitwiseBuiltinApplications !== undefined && message.bitwiseBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.bitwiseBuiltinApplications) !== message.bitwiseBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.bitwiseBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(64).uint64(message.bitwiseBuiltinApplications.toString());
    }
    if (message.keccakBuiltinApplications !== undefined && message.keccakBuiltinApplications !== BigInt("0")) {
      if (BigInt.asUintN(64, message.keccakBuiltinApplications) !== message.keccakBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.keccakBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(72).uint64(message.keccakBuiltinApplications.toString());
    }
    if (message.segmentArenaBuiltin !== undefined && message.segmentArenaBuiltin !== BigInt("0")) {
      if (BigInt.asUintN(64, message.segmentArenaBuiltin) !== message.segmentArenaBuiltin) {
        throw new globalThis.Error("value provided for field message.segmentArenaBuiltin of type uint64 too large");
      }
      writer.uint32(80).uint64(message.segmentArenaBuiltin.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputationResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputationResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.steps = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.memoryHoles = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rangeCheckBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pedersenBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.poseidonBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ecOpBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ecdsaBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.bitwiseBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.keccakBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.segmentArenaBuiltin = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputationResources {
    return {
      steps: isSet(object.steps) ? BigInt(object.steps) : BigInt("0"),
      memoryHoles: isSet(object.memoryHoles) ? BigInt(object.memoryHoles) : BigInt("0"),
      rangeCheckBuiltinApplications: isSet(object.rangeCheckBuiltinApplications)
        ? BigInt(object.rangeCheckBuiltinApplications)
        : BigInt("0"),
      pedersenBuiltinApplications: isSet(object.pedersenBuiltinApplications)
        ? BigInt(object.pedersenBuiltinApplications)
        : BigInt("0"),
      poseidonBuiltinApplications: isSet(object.poseidonBuiltinApplications)
        ? BigInt(object.poseidonBuiltinApplications)
        : BigInt("0"),
      ecOpBuiltinApplications: isSet(object.ecOpBuiltinApplications)
        ? BigInt(object.ecOpBuiltinApplications)
        : BigInt("0"),
      ecdsaBuiltinApplications: isSet(object.ecdsaBuiltinApplications)
        ? BigInt(object.ecdsaBuiltinApplications)
        : BigInt("0"),
      bitwiseBuiltinApplications: isSet(object.bitwiseBuiltinApplications)
        ? BigInt(object.bitwiseBuiltinApplications)
        : BigInt("0"),
      keccakBuiltinApplications: isSet(object.keccakBuiltinApplications)
        ? BigInt(object.keccakBuiltinApplications)
        : BigInt("0"),
      segmentArenaBuiltin: isSet(object.segmentArenaBuiltin) ? BigInt(object.segmentArenaBuiltin) : BigInt("0"),
    };
  },

  toJSON(message: ComputationResources): unknown {
    const obj: any = {};
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      obj.steps = message.steps.toString();
    }
    if (message.memoryHoles !== undefined && message.memoryHoles !== BigInt("0")) {
      obj.memoryHoles = message.memoryHoles.toString();
    }
    if (message.rangeCheckBuiltinApplications !== undefined && message.rangeCheckBuiltinApplications !== BigInt("0")) {
      obj.rangeCheckBuiltinApplications = message.rangeCheckBuiltinApplications.toString();
    }
    if (message.pedersenBuiltinApplications !== undefined && message.pedersenBuiltinApplications !== BigInt("0")) {
      obj.pedersenBuiltinApplications = message.pedersenBuiltinApplications.toString();
    }
    if (message.poseidonBuiltinApplications !== undefined && message.poseidonBuiltinApplications !== BigInt("0")) {
      obj.poseidonBuiltinApplications = message.poseidonBuiltinApplications.toString();
    }
    if (message.ecOpBuiltinApplications !== undefined && message.ecOpBuiltinApplications !== BigInt("0")) {
      obj.ecOpBuiltinApplications = message.ecOpBuiltinApplications.toString();
    }
    if (message.ecdsaBuiltinApplications !== undefined && message.ecdsaBuiltinApplications !== BigInt("0")) {
      obj.ecdsaBuiltinApplications = message.ecdsaBuiltinApplications.toString();
    }
    if (message.bitwiseBuiltinApplications !== undefined && message.bitwiseBuiltinApplications !== BigInt("0")) {
      obj.bitwiseBuiltinApplications = message.bitwiseBuiltinApplications.toString();
    }
    if (message.keccakBuiltinApplications !== undefined && message.keccakBuiltinApplications !== BigInt("0")) {
      obj.keccakBuiltinApplications = message.keccakBuiltinApplications.toString();
    }
    if (message.segmentArenaBuiltin !== undefined && message.segmentArenaBuiltin !== BigInt("0")) {
      obj.segmentArenaBuiltin = message.segmentArenaBuiltin.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputationResources>): ComputationResources {
    return ComputationResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputationResources>): ComputationResources {
    const message = createBaseComputationResources() as any;
    message.steps = object.steps ?? BigInt("0");
    message.memoryHoles = object.memoryHoles ?? BigInt("0");
    message.rangeCheckBuiltinApplications = object.rangeCheckBuiltinApplications ?? BigInt("0");
    message.pedersenBuiltinApplications = object.pedersenBuiltinApplications ?? BigInt("0");
    message.poseidonBuiltinApplications = object.poseidonBuiltinApplications ?? BigInt("0");
    message.ecOpBuiltinApplications = object.ecOpBuiltinApplications ?? BigInt("0");
    message.ecdsaBuiltinApplications = object.ecdsaBuiltinApplications ?? BigInt("0");
    message.bitwiseBuiltinApplications = object.bitwiseBuiltinApplications ?? BigInt("0");
    message.keccakBuiltinApplications = object.keccakBuiltinApplications ?? BigInt("0");
    message.segmentArenaBuiltin = object.segmentArenaBuiltin ?? BigInt("0");
    return message;
  },
};

function createBaseDataAvailabilityResources(): DataAvailabilityResources {
  return { l1Gas: BigInt("0"), l1DataGas: BigInt("0") };
}

export const DataAvailabilityResources = {
  encode(message: DataAvailabilityResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1Gas) !== message.l1Gas) {
        throw new globalThis.Error("value provided for field message.l1Gas of type uint64 too large");
      }
      writer.uint32(8).uint64(message.l1Gas.toString());
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1DataGas) !== message.l1DataGas) {
        throw new globalThis.Error("value provided for field message.l1DataGas of type uint64 too large");
      }
      writer.uint32(16).uint64(message.l1DataGas.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataAvailabilityResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataAvailabilityResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.l1Gas = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.l1DataGas = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataAvailabilityResources {
    return {
      l1Gas: isSet(object.l1Gas) ? BigInt(object.l1Gas) : BigInt("0"),
      l1DataGas: isSet(object.l1DataGas) ? BigInt(object.l1DataGas) : BigInt("0"),
    };
  },

  toJSON(message: DataAvailabilityResources): unknown {
    const obj: any = {};
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      obj.l1Gas = message.l1Gas.toString();
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      obj.l1DataGas = message.l1DataGas.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataAvailabilityResources>): DataAvailabilityResources {
    return DataAvailabilityResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataAvailabilityResources>): DataAvailabilityResources {
    const message = createBaseDataAvailabilityResources() as any;
    message.l1Gas = object.l1Gas ?? BigInt("0");
    message.l1DataGas = object.l1DataGas ?? BigInt("0");
    return message;
  },
};

function createBaseResourceBoundsMapping(): ResourceBoundsMapping {
  return { l1Gas: undefined, l2Gas: undefined };
}

export const ResourceBoundsMapping = {
  encode(message: ResourceBoundsMapping, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.l1Gas !== undefined) {
      ResourceBounds.encode(message.l1Gas, writer.uint32(10).fork()).ldelim();
    }
    if (message.l2Gas !== undefined) {
      ResourceBounds.encode(message.l2Gas, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceBoundsMapping {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBoundsMapping() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.l1Gas = ResourceBounds.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.l2Gas = ResourceBounds.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceBoundsMapping {
    return {
      l1Gas: isSet(object.l1Gas) ? ResourceBounds.fromJSON(object.l1Gas) : undefined,
      l2Gas: isSet(object.l2Gas) ? ResourceBounds.fromJSON(object.l2Gas) : undefined,
    };
  },

  toJSON(message: ResourceBoundsMapping): unknown {
    const obj: any = {};
    if (message.l1Gas !== undefined) {
      obj.l1Gas = ResourceBounds.toJSON(message.l1Gas);
    }
    if (message.l2Gas !== undefined) {
      obj.l2Gas = ResourceBounds.toJSON(message.l2Gas);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceBoundsMapping>): ResourceBoundsMapping {
    return ResourceBoundsMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceBoundsMapping>): ResourceBoundsMapping {
    const message = createBaseResourceBoundsMapping() as any;
    message.l1Gas = (object.l1Gas !== undefined && object.l1Gas !== null)
      ? ResourceBounds.fromPartial(object.l1Gas)
      : undefined;
    message.l2Gas = (object.l2Gas !== undefined && object.l2Gas !== null)
      ? ResourceBounds.fromPartial(object.l2Gas)
      : undefined;
    return message;
  },
};

function createBaseResourceBounds(): ResourceBounds {
  return { maxAmount: BigInt("0"), maxPricePerUnit: undefined };
}

export const ResourceBounds = {
  encode(message: ResourceBounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      if (BigInt.asUintN(64, message.maxAmount) !== message.maxAmount) {
        throw new globalThis.Error("value provided for field message.maxAmount of type uint64 too large");
      }
      writer.uint32(8).uint64(message.maxAmount.toString());
    }
    if (message.maxPricePerUnit !== undefined) {
      Uint128.encode(message.maxPricePerUnit, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceBounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBounds() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxAmount = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxPricePerUnit = Uint128.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceBounds {
    return {
      maxAmount: isSet(object.maxAmount) ? BigInt(object.maxAmount) : BigInt("0"),
      maxPricePerUnit: isSet(object.maxPricePerUnit) ? Uint128.fromJSON(object.maxPricePerUnit) : undefined,
    };
  },

  toJSON(message: ResourceBounds): unknown {
    const obj: any = {};
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      obj.maxAmount = message.maxAmount.toString();
    }
    if (message.maxPricePerUnit !== undefined) {
      obj.maxPricePerUnit = Uint128.toJSON(message.maxPricePerUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceBounds>): ResourceBounds {
    return ResourceBounds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceBounds>): ResourceBounds {
    const message = createBaseResourceBounds() as any;
    message.maxAmount = object.maxAmount ?? BigInt("0");
    message.maxPricePerUnit = (object.maxPricePerUnit !== undefined && object.maxPricePerUnit !== null)
      ? Uint128.fromPartial(object.maxPricePerUnit)
      : undefined;
    return message;
  },
};

function createBaseUint128(): Uint128 {
  return { low: BigInt("0"), high: BigInt("0") };
}

export const Uint128 = {
  encode(message: Uint128, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.low !== undefined && message.low !== BigInt("0")) {
      if (BigInt.asUintN(64, message.low) !== message.low) {
        throw new globalThis.Error("value provided for field message.low of type uint64 too large");
      }
      writer.uint32(8).uint64(message.low.toString());
    }
    if (message.high !== undefined && message.high !== BigInt("0")) {
      if (BigInt.asUintN(64, message.high) !== message.high) {
        throw new globalThis.Error("value provided for field message.high of type uint64 too large");
      }
      writer.uint32(16).uint64(message.high.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Uint128 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUint128() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.low = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.high = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Uint128 {
    return {
      low: isSet(object.low) ? BigInt(object.low) : BigInt("0"),
      high: isSet(object.high) ? BigInt(object.high) : BigInt("0"),
    };
  },

  toJSON(message: Uint128): unknown {
    const obj: any = {};
    if (message.low !== undefined && message.low !== BigInt("0")) {
      obj.low = message.low.toString();
    }
    if (message.high !== undefined && message.high !== BigInt("0")) {
      obj.high = message.high.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Uint128>): Uint128 {
    return Uint128.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Uint128>): Uint128 {
    const message = createBaseUint128() as any;
    message.low = object.low ?? BigInt("0");
    message.high = object.high ?? BigInt("0");
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds?.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
