// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: data.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { FieldElement } from "./common.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "starknet.v2";

/** Starknet DNA definitions (data). */

export enum TransactionStatus {
  UNSPECIFIED = 0,
  SUCCEEDED = 1,
  REVERTED = 2,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_UNSPECIFIED":
      return TransactionStatus.UNSPECIFIED;
    case 1:
    case "TRANSACTION_STATUS_SUCCEEDED":
      return TransactionStatus.SUCCEEDED;
    case 2:
    case "TRANSACTION_STATUS_REVERTED":
      return TransactionStatus.REVERTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.UNSPECIFIED:
      return "TRANSACTION_STATUS_UNSPECIFIED";
    case TransactionStatus.SUCCEEDED:
      return "TRANSACTION_STATUS_SUCCEEDED";
    case TransactionStatus.REVERTED:
      return "TRANSACTION_STATUS_REVERTED";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum L1DataAvailabilityMode {
  /** UNSPECIFIED - Unknown DA. */
  UNSPECIFIED = 0,
  /** BLOB - Data published via blobs. */
  BLOB = 1,
  /** CALLDATA - Data published via calldata. */
  CALLDATA = 2,
  UNRECOGNIZED = -1,
}

export function l1DataAvailabilityModeFromJSON(object: any): L1DataAvailabilityMode {
  switch (object) {
    case 0:
    case "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return L1DataAvailabilityMode.UNSPECIFIED;
    case 1:
    case "L1_DATA_AVAILABILITY_MODE_BLOB":
      return L1DataAvailabilityMode.BLOB;
    case 2:
    case "L1_DATA_AVAILABILITY_MODE_CALLDATA":
      return L1DataAvailabilityMode.CALLDATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return L1DataAvailabilityMode.UNRECOGNIZED;
  }
}

export function l1DataAvailabilityModeToJSON(object: L1DataAvailabilityMode): string {
  switch (object) {
    case L1DataAvailabilityMode.UNSPECIFIED:
      return "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case L1DataAvailabilityMode.BLOB:
      return "L1_DATA_AVAILABILITY_MODE_BLOB";
    case L1DataAvailabilityMode.CALLDATA:
      return "L1_DATA_AVAILABILITY_MODE_CALLDATA";
    case L1DataAvailabilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction execution status. */
export enum ExecutionStatus {
  /** UNSPECIFIED - Unknown execution status. */
  UNSPECIFIED = 0,
  /** SUCCEEDED - Transaction succeeded. */
  SUCCEEDED = 1,
  /** REVERTED - Transaction reverted. */
  REVERTED = 2,
  UNRECOGNIZED = -1,
}

export function executionStatusFromJSON(object: any): ExecutionStatus {
  switch (object) {
    case 0:
    case "EXECUTION_STATUS_UNSPECIFIED":
      return ExecutionStatus.UNSPECIFIED;
    case 1:
    case "EXECUTION_STATUS_SUCCEEDED":
      return ExecutionStatus.SUCCEEDED;
    case 2:
    case "EXECUTION_STATUS_REVERTED":
      return ExecutionStatus.REVERTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionStatus.UNRECOGNIZED;
  }
}

export function executionStatusToJSON(object: ExecutionStatus): string {
  switch (object) {
    case ExecutionStatus.UNSPECIFIED:
      return "EXECUTION_STATUS_UNSPECIFIED";
    case ExecutionStatus.SUCCEEDED:
      return "EXECUTION_STATUS_SUCCEEDED";
    case ExecutionStatus.REVERTED:
      return "EXECUTION_STATUS_REVERTED";
    case ExecutionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Price unit. */
export enum PriceUnit {
  /** UNSPECIFIED - Unknown price unit. */
  UNSPECIFIED = 0,
  /** WEI - WEI. */
  WEI = 1,
  /** FRI - FRI. */
  FRI = 2,
  UNRECOGNIZED = -1,
}

export function priceUnitFromJSON(object: any): PriceUnit {
  switch (object) {
    case 0:
    case "PRICE_UNIT_UNSPECIFIED":
      return PriceUnit.UNSPECIFIED;
    case 1:
    case "PRICE_UNIT_WEI":
      return PriceUnit.WEI;
    case 2:
    case "PRICE_UNIT_FRI":
      return PriceUnit.FRI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PriceUnit.UNRECOGNIZED;
  }
}

export function priceUnitToJSON(object: PriceUnit): string {
  switch (object) {
    case PriceUnit.UNSPECIFIED:
      return "PRICE_UNIT_UNSPECIFIED";
    case PriceUnit.WEI:
      return "PRICE_UNIT_WEI";
    case PriceUnit.FRI:
      return "PRICE_UNIT_FRI";
    case PriceUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DA mode. */
export enum DataAvailabilityMode {
  /** UNSPECIFIED - Unknown DA. */
  UNSPECIFIED = 0,
  /** L1 - L1. */
  L1 = 1,
  /** L2 - L2. */
  L2 = 2,
  UNRECOGNIZED = -1,
}

export function dataAvailabilityModeFromJSON(object: any): DataAvailabilityMode {
  switch (object) {
    case 0:
    case "DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return DataAvailabilityMode.UNSPECIFIED;
    case 1:
    case "DATA_AVAILABILITY_MODE_L1":
      return DataAvailabilityMode.L1;
    case 2:
    case "DATA_AVAILABILITY_MODE_L2":
      return DataAvailabilityMode.L2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataAvailabilityMode.UNRECOGNIZED;
  }
}

export function dataAvailabilityModeToJSON(object: DataAvailabilityMode): string {
  switch (object) {
    case DataAvailabilityMode.UNSPECIFIED:
      return "DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case DataAvailabilityMode.L1:
      return "DATA_AVAILABILITY_MODE_L1";
    case DataAvailabilityMode.L2:
      return "DATA_AVAILABILITY_MODE_L2";
    case DataAvailabilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CallType {
  UNSPECIFIED = 0,
  LIBRARY_CALL = 1,
  CALL = 2,
  DELEGATE = 3,
  UNRECOGNIZED = -1,
}

export function callTypeFromJSON(object: any): CallType {
  switch (object) {
    case 0:
    case "CALL_TYPE_UNSPECIFIED":
      return CallType.UNSPECIFIED;
    case 1:
    case "CALL_TYPE_LIBRARY_CALL":
      return CallType.LIBRARY_CALL;
    case 2:
    case "CALL_TYPE_CALL":
      return CallType.CALL;
    case 3:
    case "CALL_TYPE_DELEGATE":
      return CallType.DELEGATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CallType.UNRECOGNIZED;
  }
}

export function callTypeToJSON(object: CallType): string {
  switch (object) {
    case CallType.UNSPECIFIED:
      return "CALL_TYPE_UNSPECIFIED";
    case CallType.LIBRARY_CALL:
      return "CALL_TYPE_LIBRARY_CALL";
    case CallType.CALL:
      return "CALL_TYPE_CALL";
    case CallType.DELEGATE:
      return "CALL_TYPE_DELEGATE";
    case CallType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Requested data, grouped by block. */
export interface Block {
  /** The header. */
  readonly header?:
    | BlockHeader
    | undefined;
  /** List of transactions. */
  readonly transactions?:
    | readonly Transaction[]
    | undefined;
  /** List of transactions receipts. */
  readonly receipts?:
    | readonly TransactionReceipt[]
    | undefined;
  /** List of events. */
  readonly events?:
    | readonly Event[]
    | undefined;
  /** List of messages. */
  readonly messages?:
    | readonly MessageToL1[]
    | undefined;
  /** List of storage changes by contract. */
  readonly storageDiffs?:
    | readonly StorageDiff[]
    | undefined;
  /** List of contract/class changes. */
  readonly contractChanges?:
    | readonly ContractChange[]
    | undefined;
  /** List of nonce updates. */
  readonly nonceUpdates?:
    | readonly NonceUpdate[]
    | undefined;
  /** List of transaction traces. */
  readonly traces?: readonly TransactionTrace[] | undefined;
}

/** Block header. */
export interface BlockHeader {
  /** Hash of the block. */
  readonly blockHash?:
    | FieldElement
    | undefined;
  /** Hash of the block's parent. */
  readonly parentBlockHash?:
    | FieldElement
    | undefined;
  /** Block height. */
  readonly blockNumber?:
    | bigint
    | undefined;
  /** Sequencer address. */
  readonly sequencerAddress?:
    | FieldElement
    | undefined;
  /** New state root after the block. */
  readonly newRoot?:
    | FieldElement
    | undefined;
  /** Timestamp when block  was produced. */
  readonly timestamp?:
    | Date
    | undefined;
  /** Starknet version. */
  readonly starknetVersion?:
    | string
    | undefined;
  /** Price of L1 gas in the block. */
  readonly l1GasPrice?:
    | ResourcePrice
    | undefined;
  /** Price of L1 data gas in the block. */
  readonly l1DataGasPrice?:
    | ResourcePrice
    | undefined;
  /** L1 data availability mode. */
  readonly l1DataAvailabilityMode?: L1DataAvailabilityMode | undefined;
}

/** A transaction. */
export interface Transaction {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** Common transaction metadata. */
  readonly meta?: TransactionMeta | undefined;
  readonly transaction?:
    | { readonly $case: "invokeV0"; readonly invokeV0: InvokeTransactionV0 }
    | { readonly $case: "invokeV1"; readonly invokeV1: InvokeTransactionV1 }
    | { readonly $case: "invokeV3"; readonly invokeV3: InvokeTransactionV3 }
    | { readonly $case: "l1Handler"; readonly l1Handler: L1HandlerTransaction }
    | { readonly $case: "deploy"; readonly deploy: DeployTransaction }
    | { readonly $case: "declareV0"; readonly declareV0: DeclareTransactionV0 }
    | { readonly $case: "declareV1"; readonly declareV1: DeclareTransactionV1 }
    | { readonly $case: "declareV2"; readonly declareV2: DeclareTransactionV2 }
    | { readonly $case: "declareV3"; readonly declareV3: DeclareTransactionV3 }
    | { readonly $case: "deployAccountV1"; readonly deployAccountV1: DeployAccountTransactionV1 }
    | { readonly $case: "deployAccountV3"; readonly deployAccountV3: DeployAccountTransactionV3 }
    | undefined;
}

export interface TransactionMeta {
  /** Transaction index. */
  readonly transactionIndex?:
    | number
    | undefined;
  /** Transaction hash. */
  readonly transactionHash?:
    | FieldElement
    | undefined;
  /** Transaction status. */
  readonly transactionStatus?: TransactionStatus | undefined;
}

export interface InvokeTransactionV0 {
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly contractAddress?: FieldElement | undefined;
  readonly entryPointSelector?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
}

export interface InvokeTransactionV1 {
  readonly senderAddress?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
}

export interface InvokeTransactionV3 {
  readonly senderAddress?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly resourceBounds?: ResourceBoundsMapping | undefined;
  readonly tip?: bigint | undefined;
  readonly paymasterData?: readonly FieldElement[] | undefined;
  readonly accountDeploymentData?: readonly FieldElement[] | undefined;
  readonly nonceDataAvailabilityMode?: DataAvailabilityMode | undefined;
  readonly feeDataAvailabilityMode?: DataAvailabilityMode | undefined;
}

export interface L1HandlerTransaction {
  readonly nonce?: bigint | undefined;
  readonly contractAddress?: FieldElement | undefined;
  readonly entryPointSelector?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
}

export interface DeployTransaction {
  readonly contractAddressSalt?: FieldElement | undefined;
  readonly constructorCalldata?: readonly FieldElement[] | undefined;
  readonly classHash?: FieldElement | undefined;
}

export interface DeclareTransactionV0 {
  readonly senderAddress?: FieldElement | undefined;
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly classHash?: FieldElement | undefined;
}

export interface DeclareTransactionV1 {
  readonly senderAddress?: FieldElement | undefined;
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly classHash?: FieldElement | undefined;
}

export interface DeclareTransactionV2 {
  readonly senderAddress?: FieldElement | undefined;
  readonly compiledClassHash?: FieldElement | undefined;
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly classHash?: FieldElement | undefined;
}

export interface DeclareTransactionV3 {
  readonly senderAddress?: FieldElement | undefined;
  readonly compiledClassHash?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly classHash?: FieldElement | undefined;
  readonly resourceBounds?: ResourceBoundsMapping | undefined;
  readonly tip?: bigint | undefined;
  readonly paymasterData?: readonly FieldElement[] | undefined;
  readonly accountDeploymentData?: readonly FieldElement[] | undefined;
  readonly nonceDataAvailabilityMode?: DataAvailabilityMode | undefined;
  readonly feeDataAvailabilityMode?: DataAvailabilityMode | undefined;
}

export interface DeployAccountTransactionV1 {
  readonly maxFee?: FieldElement | undefined;
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly contractAddressSalt?: FieldElement | undefined;
  readonly constructorCalldata?: readonly FieldElement[] | undefined;
  readonly classHash?: FieldElement | undefined;
}

export interface DeployAccountTransactionV3 {
  readonly signature?: readonly FieldElement[] | undefined;
  readonly nonce?: FieldElement | undefined;
  readonly contractAddressSalt?: FieldElement | undefined;
  readonly constructorCalldata?: readonly FieldElement[] | undefined;
  readonly classHash?: FieldElement | undefined;
  readonly resourceBounds?: ResourceBoundsMapping | undefined;
  readonly tip?: bigint | undefined;
  readonly paymasterData?: readonly FieldElement[] | undefined;
  readonly nonceDataAvailabilityMode?: DataAvailabilityMode | undefined;
  readonly feeDataAvailabilityMode?: DataAvailabilityMode | undefined;
}

export interface TransactionReceipt {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** Common transaction receipt metadata. */
  readonly meta?: TransactionReceiptMeta | undefined;
  readonly receipt?:
    | { readonly $case: "invoke"; readonly invoke: InvokeTransactionReceipt }
    | { readonly $case: "l1Handler"; readonly l1Handler: L1HandlerTransactionReceipt }
    | { readonly $case: "declare"; readonly declare: DeclareTransactionReceipt }
    | { readonly $case: "deploy"; readonly deploy: DeployTransactionReceipt }
    | { readonly $case: "deployAccount"; readonly deployAccount: DeployAccountTransactionReceipt }
    | undefined;
}

export interface TransactionReceiptMeta {
  readonly transactionIndex?: number | undefined;
  readonly transactionHash?: FieldElement | undefined;
  readonly actualFee?: FeePayment | undefined;
  readonly executionResources?: ExecutionResources | undefined;
  readonly executionResult?: { readonly $case: "succeeded"; readonly succeeded: ExecutionSucceeded } | {
    readonly $case: "reverted";
    readonly reverted: ExecutionReverted;
  } | undefined;
}

export interface ExecutionSucceeded {
}

export interface ExecutionReverted {
  readonly reason?: string | undefined;
}

export interface InvokeTransactionReceipt {
}

export interface L1HandlerTransactionReceipt {
  readonly messageHash?: Uint8Array | undefined;
}

export interface DeclareTransactionReceipt {
}

export interface DeployTransactionReceipt {
  readonly contractAddress?: FieldElement | undefined;
}

export interface DeployAccountTransactionReceipt {
  readonly contractAddress?: FieldElement | undefined;
}

/** Transaction events. */
export interface Event {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** The contract that emitted the event. */
  readonly address?:
    | FieldElement
    | undefined;
  /** The event keys. */
  readonly keys?:
    | readonly FieldElement[]
    | undefined;
  /** The event data. */
  readonly data?:
    | readonly FieldElement[]
    | undefined;
  /** The event index. */
  readonly eventIndex?:
    | number
    | undefined;
  /** Transaction index. */
  readonly transactionIndex?:
    | number
    | undefined;
  /** Transaction hash. */
  readonly transactionHash?:
    | FieldElement
    | undefined;
  /** Transaction status. */
  readonly transactionStatus?:
    | TransactionStatus
    | undefined;
  /** Event index in the transaction. */
  readonly eventIndexInTransaction?: number | undefined;
}

export interface MessageToL1 {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** The contract sending the message. */
  readonly fromAddress?:
    | FieldElement
    | undefined;
  /** Target address. */
  readonly toAddress?:
    | FieldElement
    | undefined;
  /** Message payload. */
  readonly payload?:
    | readonly FieldElement[]
    | undefined;
  /** Message index. */
  readonly messageIndex?:
    | number
    | undefined;
  /** Transaction index. */
  readonly transactionIndex?:
    | number
    | undefined;
  /** Transaction hash. */
  readonly transactionHash?:
    | FieldElement
    | undefined;
  /** Transaction status. */
  readonly transactionStatus?:
    | TransactionStatus
    | undefined;
  /** Message index in the transaction. */
  readonly messageIndexInTransaction?: number | undefined;
}

/** Price of a unit of a resource. */
export interface ResourcePrice {
  /** Price in fri (10^-18 strk). */
  readonly priceInFri?:
    | FieldElement
    | undefined;
  /** Price in wei (10^-18 eth). */
  readonly priceInWei?: FieldElement | undefined;
}

/** A Starknet fee payment. */
export interface FeePayment {
  /** Amount paid. */
  readonly amount?:
    | FieldElement
    | undefined;
  /** Unit of the amount. */
  readonly unit?: PriceUnit | undefined;
}

/** Execution resources. */
export interface ExecutionResources {
  /** Computation resources. */
  readonly computation?:
    | ComputationResources
    | undefined;
  /** Data availability resources. */
  readonly dataAvailability?: DataAvailabilityResources | undefined;
}

/** Computation resources. */
export interface ComputationResources {
  /** The number of Cairo steps used. */
  readonly steps?:
    | bigint
    | undefined;
  /** The number of unused memory cells. */
  readonly memoryHoles?:
    | bigint
    | undefined;
  /** The number of RANGE_CHECK builtin instances. */
  readonly rangeCheckBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of Pedersen builtin instances. */
  readonly pedersenBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of Poseidon builtin instances. */
  readonly poseidonBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of EC_OP builtin instances. */
  readonly ecOpBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of ECDSA builtin instances. */
  readonly ecdsaBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of BITWISE builtin instances. */
  readonly bitwiseBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of KECCAK builtin instances. */
  readonly keccakBuiltinApplications?:
    | bigint
    | undefined;
  /** The number of accesses to the segment arena. */
  readonly segmentArenaBuiltin?: bigint | undefined;
}

export interface DataAvailabilityResources {
  /** The gas consumed by this transaction's data, 0 if it uses data gas for DA. */
  readonly l1Gas?:
    | bigint
    | undefined;
  /** The data gas consumed by this transaction's data, 0 if it uses gas for DA. */
  readonly l1DataGas?: bigint | undefined;
}

export interface ResourceBoundsMapping {
  /** Maximum amount and price of L1 gas. */
  readonly l1Gas?:
    | ResourceBounds
    | undefined;
  /** Maximum amount and price of L2 gas. */
  readonly l2Gas?: ResourceBounds | undefined;
}

export interface ResourceBounds {
  /** The maximum amount of resources that can be consumed by a transaction. */
  readonly maxAmount?:
    | bigint
    | undefined;
  /** / The max price per unit of resource. */
  readonly maxPricePerUnit?: Uint128 | undefined;
}

export interface Uint128 {
  readonly x0?: bigint | undefined;
  readonly x1?: bigint | undefined;
}

/** Difference in storage values for a contract. */
export interface StorageDiff {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** The contract address. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** Entries that changed. */
  readonly storageEntries?: readonly StorageEntry[] | undefined;
}

/** Storage entry. */
export interface StorageEntry {
  /** Storage location. */
  readonly key?:
    | FieldElement
    | undefined;
  /** Storage value. */
  readonly value?: FieldElement | undefined;
}

/** A class/contract change. */
export interface ContractChange {
  readonly filterIds?: readonly number[] | undefined;
  readonly change?:
    | { readonly $case: "declaredClass"; readonly declaredClass: DeclaredClass }
    | { readonly $case: "replacedClass"; readonly replacedClass: ReplacedClass }
    | { readonly $case: "deployedContract"; readonly deployedContract: DeployedContract }
    | undefined;
}

/** Class declared. */
export interface DeclaredClass {
  /** Class hash of the newly declared class. */
  readonly classHash?:
    | FieldElement
    | undefined;
  /**
   * Hash of the cairo assembly resulting from the sierra compilation.
   *
   * If undefined, it's the result of a deprecated Cairo 0 declaration.
   */
  readonly compiledClassHash?: FieldElement | undefined;
}

/** Class replaced. */
export interface ReplacedClass {
  /** The address of the contract whose class was replaced. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** The new class hash. */
  readonly classHash?: FieldElement | undefined;
}

/** Contract deployed. */
export interface DeployedContract {
  /** Address of the newly deployed contract. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** Class hash of the deployed contract. */
  readonly classHash?: FieldElement | undefined;
}

/** Nonce update. */
export interface NonceUpdate {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** Contract address. */
  readonly contractAddress?:
    | FieldElement
    | undefined;
  /** New nonce value. */
  readonly nonce?: FieldElement | undefined;
}

export interface TransactionTrace {
  readonly filterIds?:
    | readonly number[]
    | undefined;
  /** Index of the transaction in the block. */
  readonly transactionIndex?:
    | number
    | undefined;
  /** Transaction hash. */
  readonly transactionHash?: FieldElement | undefined;
  readonly traceRoot?:
    | { readonly $case: "invoke"; readonly invoke: InvokeTransactionTrace }
    | { readonly $case: "declare"; readonly declare: DeclareTransactionTrace }
    | { readonly $case: "deployAccount"; readonly deployAccount: DeployAccountTransactionTrace }
    | { readonly $case: "l1Handler"; readonly l1Handler: L1HandlerTransactionTrace }
    | undefined;
}

export interface InvokeTransactionTrace {
  readonly validateInvocation?: FunctionInvocation | undefined;
  readonly executeInvocation?: { readonly $case: "success"; readonly success: FunctionInvocation } | {
    readonly $case: "reverted";
    readonly reverted: ExecutionReverted;
  } | undefined;
  readonly feeTransferInvocation?: FunctionInvocation | undefined;
}

export interface DeclareTransactionTrace {
  readonly validateInvocation?: FunctionInvocation | undefined;
  readonly feeTransferInvocation?: FunctionInvocation | undefined;
}

export interface DeployAccountTransactionTrace {
  readonly validateInvocation?: FunctionInvocation | undefined;
  readonly constructorInvocation?: FunctionInvocation | undefined;
  readonly feeTransferInvocation?: FunctionInvocation | undefined;
}

export interface L1HandlerTransactionTrace {
  readonly functionInvocation?: FunctionInvocation | undefined;
}

export interface FunctionInvocation {
  readonly contractAddress?: FieldElement | undefined;
  readonly entryPointSelector?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
  readonly callerAddress?: FieldElement | undefined;
  readonly classHash?: FieldElement | undefined;
  readonly callType?: CallType | undefined;
  readonly result?: readonly FieldElement[] | undefined;
  readonly calls?: readonly FunctionInvocation[] | undefined;
  readonly events?: readonly number[] | undefined;
  readonly messages?: readonly number[] | undefined;
}

export interface FunctionCall {
  readonly contractAddress?: FieldElement | undefined;
  readonly entryPointSelector?: FieldElement | undefined;
  readonly calldata?: readonly FieldElement[] | undefined;
}

function createBaseBlock(): Block {
  return {
    header: undefined,
    transactions: [],
    receipts: [],
    events: [],
    messages: [],
    storageDiffs: [],
    contractChanges: [],
    nonceUpdates: [],
    traces: [],
  };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactions !== undefined && message.transactions.length !== 0) {
      for (const v of message.transactions) {
        Transaction.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.receipts !== undefined && message.receipts.length !== 0) {
      for (const v of message.receipts) {
        TransactionReceipt.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.events !== undefined && message.events.length !== 0) {
      for (const v of message.events) {
        Event.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.messages !== undefined && message.messages.length !== 0) {
      for (const v of message.messages) {
        MessageToL1.encode(v!, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.storageDiffs !== undefined && message.storageDiffs.length !== 0) {
      for (const v of message.storageDiffs) {
        StorageDiff.encode(v!, writer.uint32(50).fork()).ldelim();
      }
    }
    if (message.contractChanges !== undefined && message.contractChanges.length !== 0) {
      for (const v of message.contractChanges) {
        ContractChange.encode(v!, writer.uint32(58).fork()).ldelim();
      }
    }
    if (message.nonceUpdates !== undefined && message.nonceUpdates.length !== 0) {
      for (const v of message.nonceUpdates) {
        NonceUpdate.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.traces !== undefined && message.traces.length !== 0) {
      for (const v of message.traces) {
        TransactionTrace.encode(v!, writer.uint32(74).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions!.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipts!.push(TransactionReceipt.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.events!.push(Event.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.messages!.push(MessageToL1.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.storageDiffs!.push(StorageDiff.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contractChanges!.push(ContractChange.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nonceUpdates!.push(NonceUpdate.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.traces!.push(TransactionTrace.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      receipts: globalThis.Array.isArray(object?.receipts)
        ? object.receipts.map((e: any) => TransactionReceipt.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => MessageToL1.fromJSON(e))
        : [],
      storageDiffs: globalThis.Array.isArray(object?.storageDiffs)
        ? object.storageDiffs.map((e: any) => StorageDiff.fromJSON(e))
        : [],
      contractChanges: globalThis.Array.isArray(object?.contractChanges)
        ? object.contractChanges.map((e: any) => ContractChange.fromJSON(e))
        : [],
      nonceUpdates: globalThis.Array.isArray(object?.nonceUpdates)
        ? object.nonceUpdates.map((e: any) => NonceUpdate.fromJSON(e))
        : [],
      traces: globalThis.Array.isArray(object?.traces)
        ? object.traces.map((e: any) => TransactionTrace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.receipts?.length) {
      obj.receipts = message.receipts.map((e) => TransactionReceipt.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageToL1.toJSON(e));
    }
    if (message.storageDiffs?.length) {
      obj.storageDiffs = message.storageDiffs.map((e) => StorageDiff.toJSON(e));
    }
    if (message.contractChanges?.length) {
      obj.contractChanges = message.contractChanges.map((e) => ContractChange.toJSON(e));
    }
    if (message.nonceUpdates?.length) {
      obj.nonceUpdates = message.nonceUpdates.map((e) => NonceUpdate.toJSON(e));
    }
    if (message.traces?.length) {
      obj.traces = message.traces.map((e) => TransactionTrace.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock() as any;
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.receipts = object.receipts?.map((e) => TransactionReceipt.fromPartial(e)) || [];
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.messages = object.messages?.map((e) => MessageToL1.fromPartial(e)) || [];
    message.storageDiffs = object.storageDiffs?.map((e) => StorageDiff.fromPartial(e)) || [];
    message.contractChanges = object.contractChanges?.map((e) => ContractChange.fromPartial(e)) || [];
    message.nonceUpdates = object.nonceUpdates?.map((e) => NonceUpdate.fromPartial(e)) || [];
    message.traces = object.traces?.map((e) => TransactionTrace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    blockHash: undefined,
    parentBlockHash: undefined,
    blockNumber: BigInt("0"),
    sequencerAddress: undefined,
    newRoot: undefined,
    timestamp: undefined,
    starknetVersion: "",
    l1GasPrice: undefined,
    l1DataGasPrice: undefined,
    l1DataAvailabilityMode: 0,
  };
}

export const BlockHeader = {
  encode(message: BlockHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== undefined) {
      FieldElement.encode(message.blockHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.parentBlockHash !== undefined) {
      FieldElement.encode(message.parentBlockHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      if (BigInt.asUintN(64, message.blockNumber) !== message.blockNumber) {
        throw new globalThis.Error("value provided for field message.blockNumber of type uint64 too large");
      }
      writer.uint32(24).uint64(message.blockNumber.toString());
    }
    if (message.sequencerAddress !== undefined) {
      FieldElement.encode(message.sequencerAddress, writer.uint32(34).fork()).ldelim();
    }
    if (message.newRoot !== undefined) {
      FieldElement.encode(message.newRoot, writer.uint32(42).fork()).ldelim();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      writer.uint32(58).string(message.starknetVersion);
    }
    if (message.l1GasPrice !== undefined) {
      ResourcePrice.encode(message.l1GasPrice, writer.uint32(66).fork()).ldelim();
    }
    if (message.l1DataGasPrice !== undefined) {
      ResourcePrice.encode(message.l1DataGasPrice, writer.uint32(74).fork()).ldelim();
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.l1DataAvailabilityMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentBlockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNumber = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sequencerAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newRoot = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.starknetVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.l1GasPrice = ResourcePrice.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.l1DataGasPrice = ResourcePrice.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.l1DataAvailabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      blockHash: isSet(object.blockHash) ? FieldElement.fromJSON(object.blockHash) : undefined,
      parentBlockHash: isSet(object.parentBlockHash) ? FieldElement.fromJSON(object.parentBlockHash) : undefined,
      blockNumber: isSet(object.blockNumber) ? BigInt(object.blockNumber) : BigInt("0"),
      sequencerAddress: isSet(object.sequencerAddress) ? FieldElement.fromJSON(object.sequencerAddress) : undefined,
      newRoot: isSet(object.newRoot) ? FieldElement.fromJSON(object.newRoot) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      starknetVersion: isSet(object.starknetVersion) ? globalThis.String(object.starknetVersion) : "",
      l1GasPrice: isSet(object.l1GasPrice) ? ResourcePrice.fromJSON(object.l1GasPrice) : undefined,
      l1DataGasPrice: isSet(object.l1DataGasPrice) ? ResourcePrice.fromJSON(object.l1DataGasPrice) : undefined,
      l1DataAvailabilityMode: isSet(object.l1DataAvailabilityMode)
        ? l1DataAvailabilityModeFromJSON(object.l1DataAvailabilityMode)
        : 0,
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.blockHash !== undefined) {
      obj.blockHash = FieldElement.toJSON(message.blockHash);
    }
    if (message.parentBlockHash !== undefined) {
      obj.parentBlockHash = FieldElement.toJSON(message.parentBlockHash);
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      obj.blockNumber = message.blockNumber.toString();
    }
    if (message.sequencerAddress !== undefined) {
      obj.sequencerAddress = FieldElement.toJSON(message.sequencerAddress);
    }
    if (message.newRoot !== undefined) {
      obj.newRoot = FieldElement.toJSON(message.newRoot);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      obj.starknetVersion = message.starknetVersion;
    }
    if (message.l1GasPrice !== undefined) {
      obj.l1GasPrice = ResourcePrice.toJSON(message.l1GasPrice);
    }
    if (message.l1DataGasPrice !== undefined) {
      obj.l1DataGasPrice = ResourcePrice.toJSON(message.l1DataGasPrice);
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      obj.l1DataAvailabilityMode = l1DataAvailabilityModeToJSON(message.l1DataAvailabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeader>): BlockHeader {
    return BlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeader>): BlockHeader {
    const message = createBaseBlockHeader() as any;
    message.blockHash = (object.blockHash !== undefined && object.blockHash !== null)
      ? FieldElement.fromPartial(object.blockHash)
      : undefined;
    message.parentBlockHash = (object.parentBlockHash !== undefined && object.parentBlockHash !== null)
      ? FieldElement.fromPartial(object.parentBlockHash)
      : undefined;
    message.blockNumber = object.blockNumber ?? BigInt("0");
    message.sequencerAddress = (object.sequencerAddress !== undefined && object.sequencerAddress !== null)
      ? FieldElement.fromPartial(object.sequencerAddress)
      : undefined;
    message.newRoot = (object.newRoot !== undefined && object.newRoot !== null)
      ? FieldElement.fromPartial(object.newRoot)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.starknetVersion = object.starknetVersion ?? "";
    message.l1GasPrice = (object.l1GasPrice !== undefined && object.l1GasPrice !== null)
      ? ResourcePrice.fromPartial(object.l1GasPrice)
      : undefined;
    message.l1DataGasPrice = (object.l1DataGasPrice !== undefined && object.l1DataGasPrice !== null)
      ? ResourcePrice.fromPartial(object.l1DataGasPrice)
      : undefined;
    message.l1DataAvailabilityMode = object.l1DataAvailabilityMode ?? 0;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { filterIds: [], meta: undefined, transaction: undefined };
}

export const Transaction = {
  encode(message: Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.meta !== undefined) {
      TransactionMeta.encode(message.meta, writer.uint32(18).fork()).ldelim();
    }
    switch (message.transaction?.$case) {
      case "invokeV0":
        InvokeTransactionV0.encode(message.transaction.invokeV0, writer.uint32(26).fork()).ldelim();
        break;
      case "invokeV1":
        InvokeTransactionV1.encode(message.transaction.invokeV1, writer.uint32(34).fork()).ldelim();
        break;
      case "invokeV3":
        InvokeTransactionV3.encode(message.transaction.invokeV3, writer.uint32(42).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransaction.encode(message.transaction.l1Handler, writer.uint32(50).fork()).ldelim();
        break;
      case "deploy":
        DeployTransaction.encode(message.transaction.deploy, writer.uint32(58).fork()).ldelim();
        break;
      case "declareV0":
        DeclareTransactionV0.encode(message.transaction.declareV0, writer.uint32(66).fork()).ldelim();
        break;
      case "declareV1":
        DeclareTransactionV1.encode(message.transaction.declareV1, writer.uint32(74).fork()).ldelim();
        break;
      case "declareV2":
        DeclareTransactionV2.encode(message.transaction.declareV2, writer.uint32(82).fork()).ldelim();
        break;
      case "declareV3":
        DeclareTransactionV3.encode(message.transaction.declareV3, writer.uint32(90).fork()).ldelim();
        break;
      case "deployAccountV1":
        DeployAccountTransactionV1.encode(message.transaction.deployAccountV1, writer.uint32(98).fork()).ldelim();
        break;
      case "deployAccountV3":
        DeployAccountTransactionV3.encode(message.transaction.deployAccountV3, writer.uint32(106).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.meta = TransactionMeta.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transaction = { $case: "invokeV0", invokeV0: InvokeTransactionV0.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transaction = { $case: "invokeV1", invokeV1: InvokeTransactionV1.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transaction = { $case: "invokeV3", invokeV3: InvokeTransactionV3.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transaction = { $case: "l1Handler", l1Handler: L1HandlerTransaction.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transaction = { $case: "deploy", deploy: DeployTransaction.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transaction = { $case: "declareV0", declareV0: DeclareTransactionV0.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transaction = { $case: "declareV1", declareV1: DeclareTransactionV1.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transaction = { $case: "declareV2", declareV2: DeclareTransactionV2.decode(reader, reader.uint32()) };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transaction = { $case: "declareV3", declareV3: DeclareTransactionV3.decode(reader, reader.uint32()) };
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transaction = {
            $case: "deployAccountV1",
            deployAccountV1: DeployAccountTransactionV1.decode(reader, reader.uint32()),
          };
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.transaction = {
            $case: "deployAccountV3",
            deployAccountV3: DeployAccountTransactionV3.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      meta: isSet(object.meta) ? TransactionMeta.fromJSON(object.meta) : undefined,
      transaction: isSet(object.invokeV0)
        ? { $case: "invokeV0", invokeV0: InvokeTransactionV0.fromJSON(object.invokeV0) }
        : isSet(object.invokeV1)
        ? { $case: "invokeV1", invokeV1: InvokeTransactionV1.fromJSON(object.invokeV1) }
        : isSet(object.invokeV3)
        ? { $case: "invokeV3", invokeV3: InvokeTransactionV3.fromJSON(object.invokeV3) }
        : isSet(object.l1Handler)
        ? { $case: "l1Handler", l1Handler: L1HandlerTransaction.fromJSON(object.l1Handler) }
        : isSet(object.deploy)
        ? { $case: "deploy", deploy: DeployTransaction.fromJSON(object.deploy) }
        : isSet(object.declareV0)
        ? { $case: "declareV0", declareV0: DeclareTransactionV0.fromJSON(object.declareV0) }
        : isSet(object.declareV1)
        ? { $case: "declareV1", declareV1: DeclareTransactionV1.fromJSON(object.declareV1) }
        : isSet(object.declareV2)
        ? { $case: "declareV2", declareV2: DeclareTransactionV2.fromJSON(object.declareV2) }
        : isSet(object.declareV3)
        ? { $case: "declareV3", declareV3: DeclareTransactionV3.fromJSON(object.declareV3) }
        : isSet(object.deployAccountV1)
        ? { $case: "deployAccountV1", deployAccountV1: DeployAccountTransactionV1.fromJSON(object.deployAccountV1) }
        : isSet(object.deployAccountV3)
        ? { $case: "deployAccountV3", deployAccountV3: DeployAccountTransactionV3.fromJSON(object.deployAccountV3) }
        : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.meta !== undefined) {
      obj.meta = TransactionMeta.toJSON(message.meta);
    }
    if (message.transaction?.$case === "invokeV0") {
      obj.invokeV0 = InvokeTransactionV0.toJSON(message.transaction.invokeV0);
    }
    if (message.transaction?.$case === "invokeV1") {
      obj.invokeV1 = InvokeTransactionV1.toJSON(message.transaction.invokeV1);
    }
    if (message.transaction?.$case === "invokeV3") {
      obj.invokeV3 = InvokeTransactionV3.toJSON(message.transaction.invokeV3);
    }
    if (message.transaction?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransaction.toJSON(message.transaction.l1Handler);
    }
    if (message.transaction?.$case === "deploy") {
      obj.deploy = DeployTransaction.toJSON(message.transaction.deploy);
    }
    if (message.transaction?.$case === "declareV0") {
      obj.declareV0 = DeclareTransactionV0.toJSON(message.transaction.declareV0);
    }
    if (message.transaction?.$case === "declareV1") {
      obj.declareV1 = DeclareTransactionV1.toJSON(message.transaction.declareV1);
    }
    if (message.transaction?.$case === "declareV2") {
      obj.declareV2 = DeclareTransactionV2.toJSON(message.transaction.declareV2);
    }
    if (message.transaction?.$case === "declareV3") {
      obj.declareV3 = DeclareTransactionV3.toJSON(message.transaction.declareV3);
    }
    if (message.transaction?.$case === "deployAccountV1") {
      obj.deployAccountV1 = DeployAccountTransactionV1.toJSON(message.transaction.deployAccountV1);
    }
    if (message.transaction?.$case === "deployAccountV3") {
      obj.deployAccountV3 = DeployAccountTransactionV3.toJSON(message.transaction.deployAccountV3);
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? TransactionMeta.fromPartial(object.meta)
      : undefined;
    if (
      object.transaction?.$case === "invokeV0" &&
      object.transaction?.invokeV0 !== undefined &&
      object.transaction?.invokeV0 !== null
    ) {
      message.transaction = {
        $case: "invokeV0",
        invokeV0: InvokeTransactionV0.fromPartial(object.transaction.invokeV0),
      };
    }
    if (
      object.transaction?.$case === "invokeV1" &&
      object.transaction?.invokeV1 !== undefined &&
      object.transaction?.invokeV1 !== null
    ) {
      message.transaction = {
        $case: "invokeV1",
        invokeV1: InvokeTransactionV1.fromPartial(object.transaction.invokeV1),
      };
    }
    if (
      object.transaction?.$case === "invokeV3" &&
      object.transaction?.invokeV3 !== undefined &&
      object.transaction?.invokeV3 !== null
    ) {
      message.transaction = {
        $case: "invokeV3",
        invokeV3: InvokeTransactionV3.fromPartial(object.transaction.invokeV3),
      };
    }
    if (
      object.transaction?.$case === "l1Handler" &&
      object.transaction?.l1Handler !== undefined &&
      object.transaction?.l1Handler !== null
    ) {
      message.transaction = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransaction.fromPartial(object.transaction.l1Handler),
      };
    }
    if (
      object.transaction?.$case === "deploy" &&
      object.transaction?.deploy !== undefined &&
      object.transaction?.deploy !== null
    ) {
      message.transaction = { $case: "deploy", deploy: DeployTransaction.fromPartial(object.transaction.deploy) };
    }
    if (
      object.transaction?.$case === "declareV0" &&
      object.transaction?.declareV0 !== undefined &&
      object.transaction?.declareV0 !== null
    ) {
      message.transaction = {
        $case: "declareV0",
        declareV0: DeclareTransactionV0.fromPartial(object.transaction.declareV0),
      };
    }
    if (
      object.transaction?.$case === "declareV1" &&
      object.transaction?.declareV1 !== undefined &&
      object.transaction?.declareV1 !== null
    ) {
      message.transaction = {
        $case: "declareV1",
        declareV1: DeclareTransactionV1.fromPartial(object.transaction.declareV1),
      };
    }
    if (
      object.transaction?.$case === "declareV2" &&
      object.transaction?.declareV2 !== undefined &&
      object.transaction?.declareV2 !== null
    ) {
      message.transaction = {
        $case: "declareV2",
        declareV2: DeclareTransactionV2.fromPartial(object.transaction.declareV2),
      };
    }
    if (
      object.transaction?.$case === "declareV3" &&
      object.transaction?.declareV3 !== undefined &&
      object.transaction?.declareV3 !== null
    ) {
      message.transaction = {
        $case: "declareV3",
        declareV3: DeclareTransactionV3.fromPartial(object.transaction.declareV3),
      };
    }
    if (
      object.transaction?.$case === "deployAccountV1" &&
      object.transaction?.deployAccountV1 !== undefined &&
      object.transaction?.deployAccountV1 !== null
    ) {
      message.transaction = {
        $case: "deployAccountV1",
        deployAccountV1: DeployAccountTransactionV1.fromPartial(object.transaction.deployAccountV1),
      };
    }
    if (
      object.transaction?.$case === "deployAccountV3" &&
      object.transaction?.deployAccountV3 !== undefined &&
      object.transaction?.deployAccountV3 !== null
    ) {
      message.transaction = {
        $case: "deployAccountV3",
        deployAccountV3: DeployAccountTransactionV3.fromPartial(object.transaction.deployAccountV3),
      };
    }
    return message;
  },
};

function createBaseTransactionMeta(): TransactionMeta {
  return { transactionIndex: 0, transactionHash: undefined, transactionStatus: 0 };
}

export const TransactionMeta = {
  encode(message: TransactionMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(8).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(24).int32(message.transactionStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionMeta {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionMeta() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.transactionIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.transactionStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionMeta {
    return {
      transactionIndex: isSet(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0,
    };
  },

  toJSON(message: TransactionMeta): unknown {
    const obj: any = {};
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionMeta>): TransactionMeta {
    return TransactionMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionMeta>): TransactionMeta {
    const message = createBaseTransactionMeta() as any;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = (object.transactionHash !== undefined && object.transactionHash !== null)
      ? FieldElement.fromPartial(object.transactionHash)
      : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    return message;
  },
};

function createBaseInvokeTransactionV0(): InvokeTransactionV0 {
  return { maxFee: undefined, signature: [], contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}

export const InvokeTransactionV0 = {
  encode(message: InvokeTransactionV0, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(34).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(50).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV0 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV0() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV0 {
    return {
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InvokeTransactionV0): unknown {
    const obj: any = {};
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV0>): InvokeTransactionV0 {
    return InvokeTransactionV0.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV0>): InvokeTransactionV0 {
    const message = createBaseInvokeTransactionV0() as any;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvokeTransactionV1(): InvokeTransactionV1 {
  return { senderAddress: undefined, calldata: [], maxFee: undefined, signature: [], nonce: undefined };
}

export const InvokeTransactionV1 = {
  encode(message: InvokeTransactionV1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV1() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV1 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
    };
  },

  toJSON(message: InvokeTransactionV1): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV1>): InvokeTransactionV1 {
    return InvokeTransactionV1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV1>): InvokeTransactionV1 {
    const message = createBaseInvokeTransactionV1() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    return message;
  },
};

function createBaseInvokeTransactionV3(): InvokeTransactionV3 {
  return {
    senderAddress: undefined,
    calldata: [],
    signature: [],
    nonce: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    accountDeploymentData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0,
  };
}

export const InvokeTransactionV3 = {
  encode(message: InvokeTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping.encode(message.resourceBounds, writer.uint32(42).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(48).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v!, writer.uint32(58).fork()).ldelim();
      }
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(72).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resourceBounds = ResourceBoundsMapping.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tip = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.paymasterData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accountDeploymentData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.nonceDataAvailabilityMode = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.feeDataAvailabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionV3 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      resourceBounds: isSet(object.resourceBounds) ? ResourceBoundsMapping.fromJSON(object.resourceBounds) : undefined,
      tip: isSet(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData)
        ? object.paymasterData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData)
        ? object.accountDeploymentData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonceDataAvailabilityMode: isSet(object.nonceDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode)
        : 0,
      feeDataAvailabilityMode: isSet(object.feeDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode)
        : 0,
    };
  },

  toJSON(message: InvokeTransactionV3): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionV3>): InvokeTransactionV3 {
    return InvokeTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionV3>): InvokeTransactionV3 {
    const message = createBaseInvokeTransactionV3() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.resourceBounds = (object.resourceBounds !== undefined && object.resourceBounds !== null)
      ? ResourceBoundsMapping.fromPartial(object.resourceBounds)
      : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  },
};

function createBaseL1HandlerTransaction(): L1HandlerTransaction {
  return { nonce: BigInt("0"), contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}

export const L1HandlerTransaction = {
  encode(message: L1HandlerTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(8).uint64(message.nonce.toString());
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(26).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): L1HandlerTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nonce = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): L1HandlerTransaction {
    return {
      nonce: isSet(object.nonce) ? BigInt(object.nonce) : BigInt("0"),
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: L1HandlerTransaction): unknown {
    const obj: any = {};
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      obj.nonce = message.nonce.toString();
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<L1HandlerTransaction>): L1HandlerTransaction {
    return L1HandlerTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<L1HandlerTransaction>): L1HandlerTransaction {
    const message = createBaseL1HandlerTransaction() as any;
    message.nonce = object.nonce ?? BigInt("0");
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployTransaction(): DeployTransaction {
  return { contractAddressSalt: undefined, constructorCalldata: [], classHash: undefined };
}

export const DeployTransaction = {
  encode(message: DeployTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(10).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransaction() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployTransaction {
    return {
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployTransaction): unknown {
    const obj: any = {};
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployTransaction>): DeployTransaction {
    return DeployTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployTransaction>): DeployTransaction {
    const message = createBaseDeployTransaction() as any;
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransactionV0(): DeclareTransactionV0 {
  return { senderAddress: undefined, maxFee: undefined, signature: [], classHash: undefined };
}

export const DeclareTransactionV0 = {
  encode(message: DeclareTransactionV0, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionV0 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV0() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionV0 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeclareTransactionV0): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionV0>): DeclareTransactionV0 {
    return DeclareTransactionV0.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionV0>): DeclareTransactionV0 {
    const message = createBaseDeclareTransactionV0() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransactionV1(): DeclareTransactionV1 {
  return { senderAddress: undefined, maxFee: undefined, signature: [], nonce: undefined, classHash: undefined };
}

export const DeclareTransactionV1 = {
  encode(message: DeclareTransactionV1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionV1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV1() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionV1 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeclareTransactionV1): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionV1>): DeclareTransactionV1 {
    return DeclareTransactionV1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionV1>): DeclareTransactionV1 {
    const message = createBaseDeclareTransactionV1() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransactionV2(): DeclareTransactionV2 {
  return {
    senderAddress: undefined,
    compiledClassHash: undefined,
    maxFee: undefined,
    signature: [],
    nonce: undefined,
    classHash: undefined,
  };
}

export const DeclareTransactionV2 = {
  encode(message: DeclareTransactionV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(42).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV2() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionV2 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeclareTransactionV2): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionV2>): DeclareTransactionV2 {
    return DeclareTransactionV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionV2>): DeclareTransactionV2 {
    const message = createBaseDeclareTransactionV2() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.compiledClassHash = (object.compiledClassHash !== undefined && object.compiledClassHash !== null)
      ? FieldElement.fromPartial(object.compiledClassHash)
      : undefined;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeclareTransactionV3(): DeclareTransactionV3 {
  return {
    senderAddress: undefined,
    compiledClassHash: undefined,
    signature: [],
    nonce: undefined,
    classHash: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    accountDeploymentData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0,
  };
}

export const DeclareTransactionV3 = {
  encode(message: DeclareTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping.encode(message.resourceBounds, writer.uint32(50).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(56).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v!, writer.uint32(74).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(88).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resourceBounds = ResourceBoundsMapping.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.tip = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.paymasterData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.accountDeploymentData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.nonceDataAvailabilityMode = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.feeDataAvailabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionV3 {
    return {
      senderAddress: isSet(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      resourceBounds: isSet(object.resourceBounds) ? ResourceBoundsMapping.fromJSON(object.resourceBounds) : undefined,
      tip: isSet(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData)
        ? object.paymasterData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData)
        ? object.accountDeploymentData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonceDataAvailabilityMode: isSet(object.nonceDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode)
        : 0,
      feeDataAvailabilityMode: isSet(object.feeDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode)
        : 0,
    };
  },

  toJSON(message: DeclareTransactionV3): unknown {
    const obj: any = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionV3>): DeclareTransactionV3 {
    return DeclareTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionV3>): DeclareTransactionV3 {
    const message = createBaseDeclareTransactionV3() as any;
    message.senderAddress = (object.senderAddress !== undefined && object.senderAddress !== null)
      ? FieldElement.fromPartial(object.senderAddress)
      : undefined;
    message.compiledClassHash = (object.compiledClassHash !== undefined && object.compiledClassHash !== null)
      ? FieldElement.fromPartial(object.compiledClassHash)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.resourceBounds = (object.resourceBounds !== undefined && object.resourceBounds !== null)
      ? ResourceBoundsMapping.fromPartial(object.resourceBounds)
      : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  },
};

function createBaseDeployAccountTransactionV1(): DeployAccountTransactionV1 {
  return {
    maxFee: undefined,
    signature: [],
    nonce: undefined,
    contractAddressSalt: undefined,
    constructorCalldata: [],
    classHash: undefined,
  };
}

export const DeployAccountTransactionV1 = {
  encode(message: DeployAccountTransactionV1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(26).fork()).ldelim();
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(34).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransactionV1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionV1() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransactionV1 {
    return {
      maxFee: isSet(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployAccountTransactionV1): unknown {
    const obj: any = {};
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransactionV1>): DeployAccountTransactionV1 {
    return DeployAccountTransactionV1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransactionV1>): DeployAccountTransactionV1 {
    const message = createBaseDeployAccountTransactionV1() as any;
    message.maxFee = (object.maxFee !== undefined && object.maxFee !== null)
      ? FieldElement.fromPartial(object.maxFee)
      : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeployAccountTransactionV3(): DeployAccountTransactionV3 {
  return {
    signature: [],
    nonce: undefined,
    contractAddressSalt: undefined,
    constructorCalldata: [],
    classHash: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0,
  };
}

export const DeployAccountTransactionV3 = {
  encode(message: DeployAccountTransactionV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v!, writer.uint32(10).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(18).fork()).ldelim();
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(26).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping.encode(message.resourceBounds, writer.uint32(50).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(56).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(72).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransactionV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionV3() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.constructorCalldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resourceBounds = ResourceBoundsMapping.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.tip = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.paymasterData!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.nonceDataAvailabilityMode = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.feeDataAvailabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransactionV3 {
    return {
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      contractAddressSalt: isSet(object.contractAddressSalt)
        ? FieldElement.fromJSON(object.contractAddressSalt)
        : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata)
        ? object.constructorCalldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      resourceBounds: isSet(object.resourceBounds) ? ResourceBoundsMapping.fromJSON(object.resourceBounds) : undefined,
      tip: isSet(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData)
        ? object.paymasterData.map((e: any) => FieldElement.fromJSON(e))
        : [],
      nonceDataAvailabilityMode: isSet(object.nonceDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode)
        : 0,
      feeDataAvailabilityMode: isSet(object.feeDataAvailabilityMode)
        ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode)
        : 0,
    };
  },

  toJSON(message: DeployAccountTransactionV3): unknown {
    const obj: any = {};
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransactionV3>): DeployAccountTransactionV3 {
    return DeployAccountTransactionV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransactionV3>): DeployAccountTransactionV3 {
    const message = createBaseDeployAccountTransactionV3() as any;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    message.contractAddressSalt = (object.contractAddressSalt !== undefined && object.contractAddressSalt !== null)
      ? FieldElement.fromPartial(object.contractAddressSalt)
      : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.resourceBounds = (object.resourceBounds !== undefined && object.resourceBounds !== null)
      ? ResourceBoundsMapping.fromPartial(object.resourceBounds)
      : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  },
};

function createBaseTransactionReceipt(): TransactionReceipt {
  return { filterIds: [], meta: undefined, receipt: undefined };
}

export const TransactionReceipt = {
  encode(message: TransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.meta !== undefined) {
      TransactionReceiptMeta.encode(message.meta, writer.uint32(18).fork()).ldelim();
    }
    switch (message.receipt?.$case) {
      case "invoke":
        InvokeTransactionReceipt.encode(message.receipt.invoke, writer.uint32(26).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransactionReceipt.encode(message.receipt.l1Handler, writer.uint32(34).fork()).ldelim();
        break;
      case "declare":
        DeclareTransactionReceipt.encode(message.receipt.declare, writer.uint32(42).fork()).ldelim();
        break;
      case "deploy":
        DeployTransactionReceipt.encode(message.receipt.deploy, writer.uint32(50).fork()).ldelim();
        break;
      case "deployAccount":
        DeployAccountTransactionReceipt.encode(message.receipt.deployAccount, writer.uint32(58).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.meta = TransactionReceiptMeta.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipt = { $case: "invoke", invoke: InvokeTransactionReceipt.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.receipt = {
            $case: "l1Handler",
            l1Handler: L1HandlerTransactionReceipt.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.receipt = { $case: "declare", declare: DeclareTransactionReceipt.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.receipt = { $case: "deploy", deploy: DeployTransactionReceipt.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.receipt = {
            $case: "deployAccount",
            deployAccount: DeployAccountTransactionReceipt.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionReceipt {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      meta: isSet(object.meta) ? TransactionReceiptMeta.fromJSON(object.meta) : undefined,
      receipt: isSet(object.invoke)
        ? { $case: "invoke", invoke: InvokeTransactionReceipt.fromJSON(object.invoke) }
        : isSet(object.l1Handler)
        ? { $case: "l1Handler", l1Handler: L1HandlerTransactionReceipt.fromJSON(object.l1Handler) }
        : isSet(object.declare)
        ? { $case: "declare", declare: DeclareTransactionReceipt.fromJSON(object.declare) }
        : isSet(object.deploy)
        ? { $case: "deploy", deploy: DeployTransactionReceipt.fromJSON(object.deploy) }
        : isSet(object.deployAccount)
        ? { $case: "deployAccount", deployAccount: DeployAccountTransactionReceipt.fromJSON(object.deployAccount) }
        : undefined,
    };
  },

  toJSON(message: TransactionReceipt): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.meta !== undefined) {
      obj.meta = TransactionReceiptMeta.toJSON(message.meta);
    }
    if (message.receipt?.$case === "invoke") {
      obj.invoke = InvokeTransactionReceipt.toJSON(message.receipt.invoke);
    }
    if (message.receipt?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransactionReceipt.toJSON(message.receipt.l1Handler);
    }
    if (message.receipt?.$case === "declare") {
      obj.declare = DeclareTransactionReceipt.toJSON(message.receipt.declare);
    }
    if (message.receipt?.$case === "deploy") {
      obj.deploy = DeployTransactionReceipt.toJSON(message.receipt.deploy);
    }
    if (message.receipt?.$case === "deployAccount") {
      obj.deployAccount = DeployAccountTransactionReceipt.toJSON(message.receipt.deployAccount);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionReceipt>): TransactionReceipt {
    return TransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionReceipt>): TransactionReceipt {
    const message = createBaseTransactionReceipt() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? TransactionReceiptMeta.fromPartial(object.meta)
      : undefined;
    if (object.receipt?.$case === "invoke" && object.receipt?.invoke !== undefined && object.receipt?.invoke !== null) {
      message.receipt = { $case: "invoke", invoke: InvokeTransactionReceipt.fromPartial(object.receipt.invoke) };
    }
    if (
      object.receipt?.$case === "l1Handler" &&
      object.receipt?.l1Handler !== undefined &&
      object.receipt?.l1Handler !== null
    ) {
      message.receipt = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransactionReceipt.fromPartial(object.receipt.l1Handler),
      };
    }
    if (
      object.receipt?.$case === "declare" && object.receipt?.declare !== undefined && object.receipt?.declare !== null
    ) {
      message.receipt = { $case: "declare", declare: DeclareTransactionReceipt.fromPartial(object.receipt.declare) };
    }
    if (object.receipt?.$case === "deploy" && object.receipt?.deploy !== undefined && object.receipt?.deploy !== null) {
      message.receipt = { $case: "deploy", deploy: DeployTransactionReceipt.fromPartial(object.receipt.deploy) };
    }
    if (
      object.receipt?.$case === "deployAccount" &&
      object.receipt?.deployAccount !== undefined &&
      object.receipt?.deployAccount !== null
    ) {
      message.receipt = {
        $case: "deployAccount",
        deployAccount: DeployAccountTransactionReceipt.fromPartial(object.receipt.deployAccount),
      };
    }
    return message;
  },
};

function createBaseTransactionReceiptMeta(): TransactionReceiptMeta {
  return {
    transactionIndex: 0,
    transactionHash: undefined,
    actualFee: undefined,
    executionResources: undefined,
    executionResult: undefined,
  };
}

export const TransactionReceiptMeta = {
  encode(message: TransactionReceiptMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(8).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.actualFee !== undefined) {
      FeePayment.encode(message.actualFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.executionResources !== undefined) {
      ExecutionResources.encode(message.executionResources, writer.uint32(34).fork()).ldelim();
    }
    switch (message.executionResult?.$case) {
      case "succeeded":
        ExecutionSucceeded.encode(message.executionResult.succeeded, writer.uint32(42).fork()).ldelim();
        break;
      case "reverted":
        ExecutionReverted.encode(message.executionResult.reverted, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionReceiptMeta {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceiptMeta() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.transactionIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actualFee = FeePayment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.executionResources = ExecutionResources.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.executionResult = {
            $case: "succeeded",
            succeeded: ExecutionSucceeded.decode(reader, reader.uint32()),
          };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.executionResult = { $case: "reverted", reverted: ExecutionReverted.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionReceiptMeta {
    return {
      transactionIndex: isSet(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      actualFee: isSet(object.actualFee) ? FeePayment.fromJSON(object.actualFee) : undefined,
      executionResources: isSet(object.executionResources)
        ? ExecutionResources.fromJSON(object.executionResources)
        : undefined,
      executionResult: isSet(object.succeeded)
        ? { $case: "succeeded", succeeded: ExecutionSucceeded.fromJSON(object.succeeded) }
        : isSet(object.reverted)
        ? { $case: "reverted", reverted: ExecutionReverted.fromJSON(object.reverted) }
        : undefined,
    };
  },

  toJSON(message: TransactionReceiptMeta): unknown {
    const obj: any = {};
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.actualFee !== undefined) {
      obj.actualFee = FeePayment.toJSON(message.actualFee);
    }
    if (message.executionResources !== undefined) {
      obj.executionResources = ExecutionResources.toJSON(message.executionResources);
    }
    if (message.executionResult?.$case === "succeeded") {
      obj.succeeded = ExecutionSucceeded.toJSON(message.executionResult.succeeded);
    }
    if (message.executionResult?.$case === "reverted") {
      obj.reverted = ExecutionReverted.toJSON(message.executionResult.reverted);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionReceiptMeta>): TransactionReceiptMeta {
    return TransactionReceiptMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionReceiptMeta>): TransactionReceiptMeta {
    const message = createBaseTransactionReceiptMeta() as any;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = (object.transactionHash !== undefined && object.transactionHash !== null)
      ? FieldElement.fromPartial(object.transactionHash)
      : undefined;
    message.actualFee = (object.actualFee !== undefined && object.actualFee !== null)
      ? FeePayment.fromPartial(object.actualFee)
      : undefined;
    message.executionResources = (object.executionResources !== undefined && object.executionResources !== null)
      ? ExecutionResources.fromPartial(object.executionResources)
      : undefined;
    if (
      object.executionResult?.$case === "succeeded" &&
      object.executionResult?.succeeded !== undefined &&
      object.executionResult?.succeeded !== null
    ) {
      message.executionResult = {
        $case: "succeeded",
        succeeded: ExecutionSucceeded.fromPartial(object.executionResult.succeeded),
      };
    }
    if (
      object.executionResult?.$case === "reverted" &&
      object.executionResult?.reverted !== undefined &&
      object.executionResult?.reverted !== null
    ) {
      message.executionResult = {
        $case: "reverted",
        reverted: ExecutionReverted.fromPartial(object.executionResult.reverted),
      };
    }
    return message;
  },
};

function createBaseExecutionSucceeded(): ExecutionSucceeded {
  return {};
}

export const ExecutionSucceeded = {
  encode(_: ExecutionSucceeded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionSucceeded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionSucceeded() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExecutionSucceeded {
    return {};
  },

  toJSON(_: ExecutionSucceeded): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExecutionSucceeded>): ExecutionSucceeded {
    return ExecutionSucceeded.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExecutionSucceeded>): ExecutionSucceeded {
    const message = createBaseExecutionSucceeded() as any;
    return message;
  },
};

function createBaseExecutionReverted(): ExecutionReverted {
  return { reason: "" };
}

export const ExecutionReverted = {
  encode(message: ExecutionReverted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== undefined && message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionReverted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionReverted() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionReverted {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: ExecutionReverted): unknown {
    const obj: any = {};
    if (message.reason !== undefined && message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionReverted>): ExecutionReverted {
    return ExecutionReverted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionReverted>): ExecutionReverted {
    const message = createBaseExecutionReverted() as any;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseInvokeTransactionReceipt(): InvokeTransactionReceipt {
  return {};
}

export const InvokeTransactionReceipt = {
  encode(_: InvokeTransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InvokeTransactionReceipt {
    return {};
  },

  toJSON(_: InvokeTransactionReceipt): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionReceipt>): InvokeTransactionReceipt {
    return InvokeTransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InvokeTransactionReceipt>): InvokeTransactionReceipt {
    const message = createBaseInvokeTransactionReceipt() as any;
    return message;
  },
};

function createBaseL1HandlerTransactionReceipt(): L1HandlerTransactionReceipt {
  return { messageHash: new Uint8Array(0) };
}

export const L1HandlerTransactionReceipt = {
  encode(message: L1HandlerTransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      writer.uint32(10).bytes(message.messageHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): L1HandlerTransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): L1HandlerTransactionReceipt {
    return { messageHash: isSet(object.messageHash) ? bytesFromBase64(object.messageHash) : new Uint8Array(0) };
  },

  toJSON(message: L1HandlerTransactionReceipt): unknown {
    const obj: any = {};
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      obj.messageHash = base64FromBytes(message.messageHash);
    }
    return obj;
  },

  create(base?: DeepPartial<L1HandlerTransactionReceipt>): L1HandlerTransactionReceipt {
    return L1HandlerTransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<L1HandlerTransactionReceipt>): L1HandlerTransactionReceipt {
    const message = createBaseL1HandlerTransactionReceipt() as any;
    message.messageHash = object.messageHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeclareTransactionReceipt(): DeclareTransactionReceipt {
  return {};
}

export const DeclareTransactionReceipt = {
  encode(_: DeclareTransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeclareTransactionReceipt {
    return {};
  },

  toJSON(_: DeclareTransactionReceipt): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionReceipt>): DeclareTransactionReceipt {
    return DeclareTransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeclareTransactionReceipt>): DeclareTransactionReceipt {
    const message = createBaseDeclareTransactionReceipt() as any;
    return message;
  },
};

function createBaseDeployTransactionReceipt(): DeployTransactionReceipt {
  return { contractAddress: undefined };
}

export const DeployTransactionReceipt = {
  encode(message: DeployTransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployTransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployTransactionReceipt {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
    };
  },

  toJSON(message: DeployTransactionReceipt): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployTransactionReceipt>): DeployTransactionReceipt {
    return DeployTransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployTransactionReceipt>): DeployTransactionReceipt {
    const message = createBaseDeployTransactionReceipt() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    return message;
  },
};

function createBaseDeployAccountTransactionReceipt(): DeployAccountTransactionReceipt {
  return { contractAddress: undefined };
}

export const DeployAccountTransactionReceipt = {
  encode(message: DeployAccountTransactionReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransactionReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionReceipt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransactionReceipt {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
    };
  },

  toJSON(message: DeployAccountTransactionReceipt): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransactionReceipt>): DeployAccountTransactionReceipt {
    return DeployAccountTransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransactionReceipt>): DeployAccountTransactionReceipt {
    const message = createBaseDeployAccountTransactionReceipt() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    filterIds: [],
    address: undefined,
    keys: [],
    data: [],
    eventIndex: 0,
    transactionIndex: 0,
    transactionHash: undefined,
    transactionStatus: 0,
    eventIndexInTransaction: 0,
  };
}

export const Event = {
  encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.address !== undefined) {
      FieldElement.encode(message.address, writer.uint32(18).fork()).ldelim();
    }
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.data !== undefined && message.data.length !== 0) {
      for (const v of message.data) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.eventIndex !== undefined && message.eventIndex !== 0) {
      writer.uint32(40).uint32(message.eventIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(48).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(58).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(64).int32(message.transactionStatus);
    }
    if (message.eventIndexInTransaction !== undefined && message.eventIndexInTransaction !== 0) {
      writer.uint32(72).uint32(message.eventIndexInTransaction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keys!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.eventIndex = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.transactionIndex = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.transactionStatus = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.eventIndexInTransaction = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      address: isSet(object.address) ? FieldElement.fromJSON(object.address) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => FieldElement.fromJSON(e)) : [],
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => FieldElement.fromJSON(e)) : [],
      eventIndex: isSet(object.eventIndex) ? globalThis.Number(object.eventIndex) : 0,
      transactionIndex: isSet(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0,
      eventIndexInTransaction: isSet(object.eventIndexInTransaction)
        ? globalThis.Number(object.eventIndexInTransaction)
        : 0,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.address !== undefined) {
      obj.address = FieldElement.toJSON(message.address);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => FieldElement.toJSON(e));
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => FieldElement.toJSON(e));
    }
    if (message.eventIndex !== undefined && message.eventIndex !== 0) {
      obj.eventIndex = Math.round(message.eventIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    if (message.eventIndexInTransaction !== undefined && message.eventIndexInTransaction !== 0) {
      obj.eventIndexInTransaction = Math.round(message.eventIndexInTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.address = (object.address !== undefined && object.address !== null)
      ? FieldElement.fromPartial(object.address)
      : undefined;
    message.keys = object.keys?.map((e) => FieldElement.fromPartial(e)) || [];
    message.data = object.data?.map((e) => FieldElement.fromPartial(e)) || [];
    message.eventIndex = object.eventIndex ?? 0;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = (object.transactionHash !== undefined && object.transactionHash !== null)
      ? FieldElement.fromPartial(object.transactionHash)
      : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    message.eventIndexInTransaction = object.eventIndexInTransaction ?? 0;
    return message;
  },
};

function createBaseMessageToL1(): MessageToL1 {
  return {
    filterIds: [],
    fromAddress: undefined,
    toAddress: undefined,
    payload: [],
    messageIndex: 0,
    transactionIndex: 0,
    transactionHash: undefined,
    transactionStatus: 0,
    messageIndexInTransaction: 0,
  };
}

export const MessageToL1 = {
  encode(message: MessageToL1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.fromAddress !== undefined) {
      FieldElement.encode(message.fromAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.toAddress !== undefined) {
      FieldElement.encode(message.toAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.payload !== undefined && message.payload.length !== 0) {
      for (const v of message.payload) {
        FieldElement.encode(v!, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.messageIndex !== undefined && message.messageIndex !== 0) {
      writer.uint32(40).uint32(message.messageIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(48).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(58).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(64).int32(message.transactionStatus);
    }
    if (message.messageIndexInTransaction !== undefined && message.messageIndexInTransaction !== 0) {
      writer.uint32(72).uint32(message.messageIndexInTransaction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageToL1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageToL1() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payload!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.messageIndex = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.transactionIndex = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.transactionStatus = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.messageIndexInTransaction = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageToL1 {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      fromAddress: isSet(object.fromAddress) ? FieldElement.fromJSON(object.fromAddress) : undefined,
      toAddress: isSet(object.toAddress) ? FieldElement.fromJSON(object.toAddress) : undefined,
      payload: globalThis.Array.isArray(object?.payload)
        ? object.payload.map((e: any) => FieldElement.fromJSON(e))
        : [],
      messageIndex: isSet(object.messageIndex) ? globalThis.Number(object.messageIndex) : 0,
      transactionIndex: isSet(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0,
      messageIndexInTransaction: isSet(object.messageIndexInTransaction)
        ? globalThis.Number(object.messageIndexInTransaction)
        : 0,
    };
  },

  toJSON(message: MessageToL1): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.fromAddress !== undefined) {
      obj.fromAddress = FieldElement.toJSON(message.fromAddress);
    }
    if (message.toAddress !== undefined) {
      obj.toAddress = FieldElement.toJSON(message.toAddress);
    }
    if (message.payload?.length) {
      obj.payload = message.payload.map((e) => FieldElement.toJSON(e));
    }
    if (message.messageIndex !== undefined && message.messageIndex !== 0) {
      obj.messageIndex = Math.round(message.messageIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    if (message.messageIndexInTransaction !== undefined && message.messageIndexInTransaction !== 0) {
      obj.messageIndexInTransaction = Math.round(message.messageIndexInTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageToL1>): MessageToL1 {
    return MessageToL1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageToL1>): MessageToL1 {
    const message = createBaseMessageToL1() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.fromAddress = (object.fromAddress !== undefined && object.fromAddress !== null)
      ? FieldElement.fromPartial(object.fromAddress)
      : undefined;
    message.toAddress = (object.toAddress !== undefined && object.toAddress !== null)
      ? FieldElement.fromPartial(object.toAddress)
      : undefined;
    message.payload = object.payload?.map((e) => FieldElement.fromPartial(e)) || [];
    message.messageIndex = object.messageIndex ?? 0;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = (object.transactionHash !== undefined && object.transactionHash !== null)
      ? FieldElement.fromPartial(object.transactionHash)
      : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    message.messageIndexInTransaction = object.messageIndexInTransaction ?? 0;
    return message;
  },
};

function createBaseResourcePrice(): ResourcePrice {
  return { priceInFri: undefined, priceInWei: undefined };
}

export const ResourcePrice = {
  encode(message: ResourcePrice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceInFri !== undefined) {
      FieldElement.encode(message.priceInFri, writer.uint32(10).fork()).ldelim();
    }
    if (message.priceInWei !== undefined) {
      FieldElement.encode(message.priceInWei, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourcePrice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePrice() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.priceInFri = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.priceInWei = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcePrice {
    return {
      priceInFri: isSet(object.priceInFri) ? FieldElement.fromJSON(object.priceInFri) : undefined,
      priceInWei: isSet(object.priceInWei) ? FieldElement.fromJSON(object.priceInWei) : undefined,
    };
  },

  toJSON(message: ResourcePrice): unknown {
    const obj: any = {};
    if (message.priceInFri !== undefined) {
      obj.priceInFri = FieldElement.toJSON(message.priceInFri);
    }
    if (message.priceInWei !== undefined) {
      obj.priceInWei = FieldElement.toJSON(message.priceInWei);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourcePrice>): ResourcePrice {
    return ResourcePrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourcePrice>): ResourcePrice {
    const message = createBaseResourcePrice() as any;
    message.priceInFri = (object.priceInFri !== undefined && object.priceInFri !== null)
      ? FieldElement.fromPartial(object.priceInFri)
      : undefined;
    message.priceInWei = (object.priceInWei !== undefined && object.priceInWei !== null)
      ? FieldElement.fromPartial(object.priceInWei)
      : undefined;
    return message;
  },
};

function createBaseFeePayment(): FeePayment {
  return { amount: undefined, unit: 0 };
}

export const FeePayment = {
  encode(message: FeePayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== undefined) {
      FieldElement.encode(message.amount, writer.uint32(10).fork()).ldelim();
    }
    if (message.unit !== undefined && message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeePayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePayment() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePayment {
    return {
      amount: isSet(object.amount) ? FieldElement.fromJSON(object.amount) : undefined,
      unit: isSet(object.unit) ? priceUnitFromJSON(object.unit) : 0,
    };
  },

  toJSON(message: FeePayment): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = FieldElement.toJSON(message.amount);
    }
    if (message.unit !== undefined && message.unit !== 0) {
      obj.unit = priceUnitToJSON(message.unit);
    }
    return obj;
  },

  create(base?: DeepPartial<FeePayment>): FeePayment {
    return FeePayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeePayment>): FeePayment {
    const message = createBaseFeePayment() as any;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? FieldElement.fromPartial(object.amount)
      : undefined;
    message.unit = object.unit ?? 0;
    return message;
  },
};

function createBaseExecutionResources(): ExecutionResources {
  return { computation: undefined, dataAvailability: undefined };
}

export const ExecutionResources = {
  encode(message: ExecutionResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.computation !== undefined) {
      ComputationResources.encode(message.computation, writer.uint32(10).fork()).ldelim();
    }
    if (message.dataAvailability !== undefined) {
      DataAvailabilityResources.encode(message.dataAvailability, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.computation = ComputationResources.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataAvailability = DataAvailabilityResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResources {
    return {
      computation: isSet(object.computation) ? ComputationResources.fromJSON(object.computation) : undefined,
      dataAvailability: isSet(object.dataAvailability)
        ? DataAvailabilityResources.fromJSON(object.dataAvailability)
        : undefined,
    };
  },

  toJSON(message: ExecutionResources): unknown {
    const obj: any = {};
    if (message.computation !== undefined) {
      obj.computation = ComputationResources.toJSON(message.computation);
    }
    if (message.dataAvailability !== undefined) {
      obj.dataAvailability = DataAvailabilityResources.toJSON(message.dataAvailability);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionResources>): ExecutionResources {
    return ExecutionResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionResources>): ExecutionResources {
    const message = createBaseExecutionResources() as any;
    message.computation = (object.computation !== undefined && object.computation !== null)
      ? ComputationResources.fromPartial(object.computation)
      : undefined;
    message.dataAvailability = (object.dataAvailability !== undefined && object.dataAvailability !== null)
      ? DataAvailabilityResources.fromPartial(object.dataAvailability)
      : undefined;
    return message;
  },
};

function createBaseComputationResources(): ComputationResources {
  return {
    steps: BigInt("0"),
    memoryHoles: undefined,
    rangeCheckBuiltinApplications: undefined,
    pedersenBuiltinApplications: undefined,
    poseidonBuiltinApplications: undefined,
    ecOpBuiltinApplications: undefined,
    ecdsaBuiltinApplications: undefined,
    bitwiseBuiltinApplications: undefined,
    keccakBuiltinApplications: undefined,
    segmentArenaBuiltin: undefined,
  };
}

export const ComputationResources = {
  encode(message: ComputationResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      if (BigInt.asUintN(64, message.steps) !== message.steps) {
        throw new globalThis.Error("value provided for field message.steps of type uint64 too large");
      }
      writer.uint32(8).uint64(message.steps.toString());
    }
    if (message.memoryHoles !== undefined) {
      if (BigInt.asUintN(64, message.memoryHoles) !== message.memoryHoles) {
        throw new globalThis.Error("value provided for field message.memoryHoles of type uint64 too large");
      }
      writer.uint32(16).uint64(message.memoryHoles.toString());
    }
    if (message.rangeCheckBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.rangeCheckBuiltinApplications) !== message.rangeCheckBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.rangeCheckBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(24).uint64(message.rangeCheckBuiltinApplications.toString());
    }
    if (message.pedersenBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.pedersenBuiltinApplications) !== message.pedersenBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.pedersenBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(32).uint64(message.pedersenBuiltinApplications.toString());
    }
    if (message.poseidonBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.poseidonBuiltinApplications) !== message.poseidonBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.poseidonBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(40).uint64(message.poseidonBuiltinApplications.toString());
    }
    if (message.ecOpBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.ecOpBuiltinApplications) !== message.ecOpBuiltinApplications) {
        throw new globalThis.Error("value provided for field message.ecOpBuiltinApplications of type uint64 too large");
      }
      writer.uint32(48).uint64(message.ecOpBuiltinApplications.toString());
    }
    if (message.ecdsaBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.ecdsaBuiltinApplications) !== message.ecdsaBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.ecdsaBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(56).uint64(message.ecdsaBuiltinApplications.toString());
    }
    if (message.bitwiseBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.bitwiseBuiltinApplications) !== message.bitwiseBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.bitwiseBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(64).uint64(message.bitwiseBuiltinApplications.toString());
    }
    if (message.keccakBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.keccakBuiltinApplications) !== message.keccakBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.keccakBuiltinApplications of type uint64 too large",
        );
      }
      writer.uint32(72).uint64(message.keccakBuiltinApplications.toString());
    }
    if (message.segmentArenaBuiltin !== undefined) {
      if (BigInt.asUintN(64, message.segmentArenaBuiltin) !== message.segmentArenaBuiltin) {
        throw new globalThis.Error("value provided for field message.segmentArenaBuiltin of type uint64 too large");
      }
      writer.uint32(80).uint64(message.segmentArenaBuiltin.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputationResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputationResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.steps = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.memoryHoles = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rangeCheckBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pedersenBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.poseidonBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ecOpBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ecdsaBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.bitwiseBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.keccakBuiltinApplications = longToBigint(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.segmentArenaBuiltin = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputationResources {
    return {
      steps: isSet(object.steps) ? BigInt(object.steps) : BigInt("0"),
      memoryHoles: isSet(object.memoryHoles) ? BigInt(object.memoryHoles) : undefined,
      rangeCheckBuiltinApplications: isSet(object.rangeCheckBuiltinApplications)
        ? BigInt(object.rangeCheckBuiltinApplications)
        : undefined,
      pedersenBuiltinApplications: isSet(object.pedersenBuiltinApplications)
        ? BigInt(object.pedersenBuiltinApplications)
        : undefined,
      poseidonBuiltinApplications: isSet(object.poseidonBuiltinApplications)
        ? BigInt(object.poseidonBuiltinApplications)
        : undefined,
      ecOpBuiltinApplications: isSet(object.ecOpBuiltinApplications)
        ? BigInt(object.ecOpBuiltinApplications)
        : undefined,
      ecdsaBuiltinApplications: isSet(object.ecdsaBuiltinApplications)
        ? BigInt(object.ecdsaBuiltinApplications)
        : undefined,
      bitwiseBuiltinApplications: isSet(object.bitwiseBuiltinApplications)
        ? BigInt(object.bitwiseBuiltinApplications)
        : undefined,
      keccakBuiltinApplications: isSet(object.keccakBuiltinApplications)
        ? BigInt(object.keccakBuiltinApplications)
        : undefined,
      segmentArenaBuiltin: isSet(object.segmentArenaBuiltin) ? BigInt(object.segmentArenaBuiltin) : undefined,
    };
  },

  toJSON(message: ComputationResources): unknown {
    const obj: any = {};
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      obj.steps = message.steps.toString();
    }
    if (message.memoryHoles !== undefined) {
      obj.memoryHoles = message.memoryHoles.toString();
    }
    if (message.rangeCheckBuiltinApplications !== undefined) {
      obj.rangeCheckBuiltinApplications = message.rangeCheckBuiltinApplications.toString();
    }
    if (message.pedersenBuiltinApplications !== undefined) {
      obj.pedersenBuiltinApplications = message.pedersenBuiltinApplications.toString();
    }
    if (message.poseidonBuiltinApplications !== undefined) {
      obj.poseidonBuiltinApplications = message.poseidonBuiltinApplications.toString();
    }
    if (message.ecOpBuiltinApplications !== undefined) {
      obj.ecOpBuiltinApplications = message.ecOpBuiltinApplications.toString();
    }
    if (message.ecdsaBuiltinApplications !== undefined) {
      obj.ecdsaBuiltinApplications = message.ecdsaBuiltinApplications.toString();
    }
    if (message.bitwiseBuiltinApplications !== undefined) {
      obj.bitwiseBuiltinApplications = message.bitwiseBuiltinApplications.toString();
    }
    if (message.keccakBuiltinApplications !== undefined) {
      obj.keccakBuiltinApplications = message.keccakBuiltinApplications.toString();
    }
    if (message.segmentArenaBuiltin !== undefined) {
      obj.segmentArenaBuiltin = message.segmentArenaBuiltin.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputationResources>): ComputationResources {
    return ComputationResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputationResources>): ComputationResources {
    const message = createBaseComputationResources() as any;
    message.steps = object.steps ?? BigInt("0");
    message.memoryHoles = object.memoryHoles ?? undefined;
    message.rangeCheckBuiltinApplications = object.rangeCheckBuiltinApplications ?? undefined;
    message.pedersenBuiltinApplications = object.pedersenBuiltinApplications ?? undefined;
    message.poseidonBuiltinApplications = object.poseidonBuiltinApplications ?? undefined;
    message.ecOpBuiltinApplications = object.ecOpBuiltinApplications ?? undefined;
    message.ecdsaBuiltinApplications = object.ecdsaBuiltinApplications ?? undefined;
    message.bitwiseBuiltinApplications = object.bitwiseBuiltinApplications ?? undefined;
    message.keccakBuiltinApplications = object.keccakBuiltinApplications ?? undefined;
    message.segmentArenaBuiltin = object.segmentArenaBuiltin ?? undefined;
    return message;
  },
};

function createBaseDataAvailabilityResources(): DataAvailabilityResources {
  return { l1Gas: BigInt("0"), l1DataGas: BigInt("0") };
}

export const DataAvailabilityResources = {
  encode(message: DataAvailabilityResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1Gas) !== message.l1Gas) {
        throw new globalThis.Error("value provided for field message.l1Gas of type uint64 too large");
      }
      writer.uint32(8).uint64(message.l1Gas.toString());
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1DataGas) !== message.l1DataGas) {
        throw new globalThis.Error("value provided for field message.l1DataGas of type uint64 too large");
      }
      writer.uint32(16).uint64(message.l1DataGas.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataAvailabilityResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataAvailabilityResources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.l1Gas = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.l1DataGas = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataAvailabilityResources {
    return {
      l1Gas: isSet(object.l1Gas) ? BigInt(object.l1Gas) : BigInt("0"),
      l1DataGas: isSet(object.l1DataGas) ? BigInt(object.l1DataGas) : BigInt("0"),
    };
  },

  toJSON(message: DataAvailabilityResources): unknown {
    const obj: any = {};
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      obj.l1Gas = message.l1Gas.toString();
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      obj.l1DataGas = message.l1DataGas.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataAvailabilityResources>): DataAvailabilityResources {
    return DataAvailabilityResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataAvailabilityResources>): DataAvailabilityResources {
    const message = createBaseDataAvailabilityResources() as any;
    message.l1Gas = object.l1Gas ?? BigInt("0");
    message.l1DataGas = object.l1DataGas ?? BigInt("0");
    return message;
  },
};

function createBaseResourceBoundsMapping(): ResourceBoundsMapping {
  return { l1Gas: undefined, l2Gas: undefined };
}

export const ResourceBoundsMapping = {
  encode(message: ResourceBoundsMapping, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.l1Gas !== undefined) {
      ResourceBounds.encode(message.l1Gas, writer.uint32(10).fork()).ldelim();
    }
    if (message.l2Gas !== undefined) {
      ResourceBounds.encode(message.l2Gas, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceBoundsMapping {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBoundsMapping() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.l1Gas = ResourceBounds.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.l2Gas = ResourceBounds.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceBoundsMapping {
    return {
      l1Gas: isSet(object.l1Gas) ? ResourceBounds.fromJSON(object.l1Gas) : undefined,
      l2Gas: isSet(object.l2Gas) ? ResourceBounds.fromJSON(object.l2Gas) : undefined,
    };
  },

  toJSON(message: ResourceBoundsMapping): unknown {
    const obj: any = {};
    if (message.l1Gas !== undefined) {
      obj.l1Gas = ResourceBounds.toJSON(message.l1Gas);
    }
    if (message.l2Gas !== undefined) {
      obj.l2Gas = ResourceBounds.toJSON(message.l2Gas);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceBoundsMapping>): ResourceBoundsMapping {
    return ResourceBoundsMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceBoundsMapping>): ResourceBoundsMapping {
    const message = createBaseResourceBoundsMapping() as any;
    message.l1Gas = (object.l1Gas !== undefined && object.l1Gas !== null)
      ? ResourceBounds.fromPartial(object.l1Gas)
      : undefined;
    message.l2Gas = (object.l2Gas !== undefined && object.l2Gas !== null)
      ? ResourceBounds.fromPartial(object.l2Gas)
      : undefined;
    return message;
  },
};

function createBaseResourceBounds(): ResourceBounds {
  return { maxAmount: BigInt("0"), maxPricePerUnit: undefined };
}

export const ResourceBounds = {
  encode(message: ResourceBounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      if (BigInt.asUintN(64, message.maxAmount) !== message.maxAmount) {
        throw new globalThis.Error("value provided for field message.maxAmount of type uint64 too large");
      }
      writer.uint32(8).uint64(message.maxAmount.toString());
    }
    if (message.maxPricePerUnit !== undefined) {
      Uint128.encode(message.maxPricePerUnit, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceBounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBounds() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxAmount = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxPricePerUnit = Uint128.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceBounds {
    return {
      maxAmount: isSet(object.maxAmount) ? BigInt(object.maxAmount) : BigInt("0"),
      maxPricePerUnit: isSet(object.maxPricePerUnit) ? Uint128.fromJSON(object.maxPricePerUnit) : undefined,
    };
  },

  toJSON(message: ResourceBounds): unknown {
    const obj: any = {};
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      obj.maxAmount = message.maxAmount.toString();
    }
    if (message.maxPricePerUnit !== undefined) {
      obj.maxPricePerUnit = Uint128.toJSON(message.maxPricePerUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceBounds>): ResourceBounds {
    return ResourceBounds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceBounds>): ResourceBounds {
    const message = createBaseResourceBounds() as any;
    message.maxAmount = object.maxAmount ?? BigInt("0");
    message.maxPricePerUnit = (object.maxPricePerUnit !== undefined && object.maxPricePerUnit !== null)
      ? Uint128.fromPartial(object.maxPricePerUnit)
      : undefined;
    return message;
  },
};

function createBaseUint128(): Uint128 {
  return { x0: BigInt("0"), x1: BigInt("0") };
}

export const Uint128 = {
  encode(message: Uint128, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x0) !== message.x0) {
        throw new globalThis.Error("value provided for field message.x0 of type uint64 too large");
      }
      writer.uint32(8).uint64(message.x0.toString());
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x1) !== message.x1) {
        throw new globalThis.Error("value provided for field message.x1 of type uint64 too large");
      }
      writer.uint32(16).uint64(message.x1.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Uint128 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUint128() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x0 = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.x1 = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Uint128 {
    return {
      x0: isSet(object.x0) ? BigInt(object.x0) : BigInt("0"),
      x1: isSet(object.x1) ? BigInt(object.x1) : BigInt("0"),
    };
  },

  toJSON(message: Uint128): unknown {
    const obj: any = {};
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      obj.x0 = message.x0.toString();
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      obj.x1 = message.x1.toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Uint128>): Uint128 {
    return Uint128.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Uint128>): Uint128 {
    const message = createBaseUint128() as any;
    message.x0 = object.x0 ?? BigInt("0");
    message.x1 = object.x1 ?? BigInt("0");
    return message;
  },
};

function createBaseStorageDiff(): StorageDiff {
  return { filterIds: [], contractAddress: undefined, storageEntries: [] };
}

export const StorageDiff = {
  encode(message: StorageDiff, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.storageEntries !== undefined && message.storageEntries.length !== 0) {
      for (const v of message.storageEntries) {
        StorageEntry.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StorageDiff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageDiff() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.storageEntries!.push(StorageEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageDiff {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      storageEntries: globalThis.Array.isArray(object?.storageEntries)
        ? object.storageEntries.map((e: any) => StorageEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageDiff): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.storageEntries?.length) {
      obj.storageEntries = message.storageEntries.map((e) => StorageEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StorageDiff>): StorageDiff {
    return StorageDiff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageDiff>): StorageDiff {
    const message = createBaseStorageDiff() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.storageEntries = object.storageEntries?.map((e) => StorageEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageEntry(): StorageEntry {
  return { key: undefined, value: undefined };
}

export const StorageEntry = {
  encode(message: StorageEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== undefined) {
      FieldElement.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.value !== undefined) {
      FieldElement.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StorageEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageEntry {
    return {
      key: isSet(object.key) ? FieldElement.fromJSON(object.key) : undefined,
      value: isSet(object.value) ? FieldElement.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StorageEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = FieldElement.toJSON(message.key);
    }
    if (message.value !== undefined) {
      obj.value = FieldElement.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StorageEntry>): StorageEntry {
    return StorageEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageEntry>): StorageEntry {
    const message = createBaseStorageEntry() as any;
    message.key = (object.key !== undefined && object.key !== null) ? FieldElement.fromPartial(object.key) : undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldElement.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseContractChange(): ContractChange {
  return { filterIds: [], change: undefined };
}

export const ContractChange = {
  encode(message: ContractChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    switch (message.change?.$case) {
      case "declaredClass":
        DeclaredClass.encode(message.change.declaredClass, writer.uint32(18).fork()).ldelim();
        break;
      case "replacedClass":
        ReplacedClass.encode(message.change.replacedClass, writer.uint32(26).fork()).ldelim();
        break;
      case "deployedContract":
        DeployedContract.encode(message.change.deployedContract, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractChange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.change = { $case: "declaredClass", declaredClass: DeclaredClass.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.change = { $case: "replacedClass", replacedClass: ReplacedClass.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.change = {
            $case: "deployedContract",
            deployedContract: DeployedContract.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractChange {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      change: isSet(object.declaredClass)
        ? { $case: "declaredClass", declaredClass: DeclaredClass.fromJSON(object.declaredClass) }
        : isSet(object.replacedClass)
        ? { $case: "replacedClass", replacedClass: ReplacedClass.fromJSON(object.replacedClass) }
        : isSet(object.deployedContract)
        ? { $case: "deployedContract", deployedContract: DeployedContract.fromJSON(object.deployedContract) }
        : undefined,
    };
  },

  toJSON(message: ContractChange): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.change?.$case === "declaredClass") {
      obj.declaredClass = DeclaredClass.toJSON(message.change.declaredClass);
    }
    if (message.change?.$case === "replacedClass") {
      obj.replacedClass = ReplacedClass.toJSON(message.change.replacedClass);
    }
    if (message.change?.$case === "deployedContract") {
      obj.deployedContract = DeployedContract.toJSON(message.change.deployedContract);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractChange>): ContractChange {
    return ContractChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractChange>): ContractChange {
    const message = createBaseContractChange() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    if (
      object.change?.$case === "declaredClass" &&
      object.change?.declaredClass !== undefined &&
      object.change?.declaredClass !== null
    ) {
      message.change = {
        $case: "declaredClass",
        declaredClass: DeclaredClass.fromPartial(object.change.declaredClass),
      };
    }
    if (
      object.change?.$case === "replacedClass" &&
      object.change?.replacedClass !== undefined &&
      object.change?.replacedClass !== null
    ) {
      message.change = {
        $case: "replacedClass",
        replacedClass: ReplacedClass.fromPartial(object.change.replacedClass),
      };
    }
    if (
      object.change?.$case === "deployedContract" &&
      object.change?.deployedContract !== undefined &&
      object.change?.deployedContract !== null
    ) {
      message.change = {
        $case: "deployedContract",
        deployedContract: DeployedContract.fromPartial(object.change.deployedContract),
      };
    }
    return message;
  },
};

function createBaseDeclaredClass(): DeclaredClass {
  return { classHash: undefined, compiledClassHash: undefined };
}

export const DeclaredClass = {
  encode(message: DeclaredClass, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclaredClass {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclaredClass() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclaredClass {
    return {
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      compiledClassHash: isSet(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
    };
  },

  toJSON(message: DeclaredClass): unknown {
    const obj: any = {};
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclaredClass>): DeclaredClass {
    return DeclaredClass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclaredClass>): DeclaredClass {
    const message = createBaseDeclaredClass() as any;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.compiledClassHash = (object.compiledClassHash !== undefined && object.compiledClassHash !== null)
      ? FieldElement.fromPartial(object.compiledClassHash)
      : undefined;
    return message;
  },
};

function createBaseReplacedClass(): ReplacedClass {
  return { contractAddress: undefined, classHash: undefined };
}

export const ReplacedClass = {
  encode(message: ReplacedClass, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReplacedClass {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplacedClass() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplacedClass {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: ReplacedClass): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplacedClass>): ReplacedClass {
    return ReplacedClass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplacedClass>): ReplacedClass {
    const message = createBaseReplacedClass() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseDeployedContract(): DeployedContract {
  return { contractAddress: undefined, classHash: undefined };
}

export const DeployedContract = {
  encode(message: DeployedContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployedContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedContract() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedContract {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
    };
  },

  toJSON(message: DeployedContract): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedContract>): DeployedContract {
    return DeployedContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedContract>): DeployedContract {
    const message = createBaseDeployedContract() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    return message;
  },
};

function createBaseNonceUpdate(): NonceUpdate {
  return { filterIds: [], contractAddress: undefined, nonce: undefined };
}

export const NonceUpdate = {
  encode(message: NonceUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NonceUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceUpdate() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonceUpdate {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      nonce: isSet(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
    };
  },

  toJSON(message: NonceUpdate): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    return obj;
  },

  create(base?: DeepPartial<NonceUpdate>): NonceUpdate {
    return NonceUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NonceUpdate>): NonceUpdate {
    const message = createBaseNonceUpdate() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.nonce = (object.nonce !== undefined && object.nonce !== null)
      ? FieldElement.fromPartial(object.nonce)
      : undefined;
    return message;
  },
};

function createBaseTransactionTrace(): TransactionTrace {
  return { filterIds: [], transactionIndex: 0, transactionHash: undefined, traceRoot: undefined };
}

export const TransactionTrace = {
  encode(message: TransactionTrace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(16).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(26).fork()).ldelim();
    }
    switch (message.traceRoot?.$case) {
      case "invoke":
        InvokeTransactionTrace.encode(message.traceRoot.invoke, writer.uint32(34).fork()).ldelim();
        break;
      case "declare":
        DeclareTransactionTrace.encode(message.traceRoot.declare, writer.uint32(42).fork()).ldelim();
        break;
      case "deployAccount":
        DeployAccountTransactionTrace.encode(message.traceRoot.deployAccount, writer.uint32(50).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransactionTrace.encode(message.traceRoot.l1Handler, writer.uint32(58).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionTrace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionTrace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds!.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.transactionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.traceRoot = { $case: "invoke", invoke: InvokeTransactionTrace.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceRoot = { $case: "declare", declare: DeclareTransactionTrace.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.traceRoot = {
            $case: "deployAccount",
            deployAccount: DeployAccountTransactionTrace.decode(reader, reader.uint32()),
          };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.traceRoot = {
            $case: "l1Handler",
            l1Handler: L1HandlerTransactionTrace.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionTrace {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds)
        ? object.filterIds.map((e: any) => globalThis.Number(e))
        : [],
      transactionIndex: isSet(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      traceRoot: isSet(object.invoke)
        ? { $case: "invoke", invoke: InvokeTransactionTrace.fromJSON(object.invoke) }
        : isSet(object.declare)
        ? { $case: "declare", declare: DeclareTransactionTrace.fromJSON(object.declare) }
        : isSet(object.deployAccount)
        ? { $case: "deployAccount", deployAccount: DeployAccountTransactionTrace.fromJSON(object.deployAccount) }
        : isSet(object.l1Handler)
        ? { $case: "l1Handler", l1Handler: L1HandlerTransactionTrace.fromJSON(object.l1Handler) }
        : undefined,
    };
  },

  toJSON(message: TransactionTrace): unknown {
    const obj: any = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.traceRoot?.$case === "invoke") {
      obj.invoke = InvokeTransactionTrace.toJSON(message.traceRoot.invoke);
    }
    if (message.traceRoot?.$case === "declare") {
      obj.declare = DeclareTransactionTrace.toJSON(message.traceRoot.declare);
    }
    if (message.traceRoot?.$case === "deployAccount") {
      obj.deployAccount = DeployAccountTransactionTrace.toJSON(message.traceRoot.deployAccount);
    }
    if (message.traceRoot?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransactionTrace.toJSON(message.traceRoot.l1Handler);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionTrace>): TransactionTrace {
    return TransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionTrace>): TransactionTrace {
    const message = createBaseTransactionTrace() as any;
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = (object.transactionHash !== undefined && object.transactionHash !== null)
      ? FieldElement.fromPartial(object.transactionHash)
      : undefined;
    if (
      object.traceRoot?.$case === "invoke" &&
      object.traceRoot?.invoke !== undefined &&
      object.traceRoot?.invoke !== null
    ) {
      message.traceRoot = { $case: "invoke", invoke: InvokeTransactionTrace.fromPartial(object.traceRoot.invoke) };
    }
    if (
      object.traceRoot?.$case === "declare" &&
      object.traceRoot?.declare !== undefined &&
      object.traceRoot?.declare !== null
    ) {
      message.traceRoot = { $case: "declare", declare: DeclareTransactionTrace.fromPartial(object.traceRoot.declare) };
    }
    if (
      object.traceRoot?.$case === "deployAccount" &&
      object.traceRoot?.deployAccount !== undefined &&
      object.traceRoot?.deployAccount !== null
    ) {
      message.traceRoot = {
        $case: "deployAccount",
        deployAccount: DeployAccountTransactionTrace.fromPartial(object.traceRoot.deployAccount),
      };
    }
    if (
      object.traceRoot?.$case === "l1Handler" &&
      object.traceRoot?.l1Handler !== undefined &&
      object.traceRoot?.l1Handler !== null
    ) {
      message.traceRoot = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransactionTrace.fromPartial(object.traceRoot.l1Handler),
      };
    }
    return message;
  },
};

function createBaseInvokeTransactionTrace(): InvokeTransactionTrace {
  return { validateInvocation: undefined, executeInvocation: undefined, feeTransferInvocation: undefined };
}

export const InvokeTransactionTrace = {
  encode(message: InvokeTransactionTrace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validateInvocation !== undefined) {
      FunctionInvocation.encode(message.validateInvocation, writer.uint32(10).fork()).ldelim();
    }
    switch (message.executeInvocation?.$case) {
      case "success":
        FunctionInvocation.encode(message.executeInvocation.success, writer.uint32(18).fork()).ldelim();
        break;
      case "reverted":
        ExecutionReverted.encode(message.executeInvocation.reverted, writer.uint32(26).fork()).ldelim();
        break;
    }
    if (message.feeTransferInvocation !== undefined) {
      FunctionInvocation.encode(message.feeTransferInvocation, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeTransactionTrace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionTrace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validateInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executeInvocation = { $case: "success", success: FunctionInvocation.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executeInvocation = {
            $case: "reverted",
            reverted: ExecutionReverted.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeTransferInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeTransactionTrace {
    return {
      validateInvocation: isSet(object.validateInvocation)
        ? FunctionInvocation.fromJSON(object.validateInvocation)
        : undefined,
      executeInvocation: isSet(object.success)
        ? { $case: "success", success: FunctionInvocation.fromJSON(object.success) }
        : isSet(object.reverted)
        ? { $case: "reverted", reverted: ExecutionReverted.fromJSON(object.reverted) }
        : undefined,
      feeTransferInvocation: isSet(object.feeTransferInvocation)
        ? FunctionInvocation.fromJSON(object.feeTransferInvocation)
        : undefined,
    };
  },

  toJSON(message: InvokeTransactionTrace): unknown {
    const obj: any = {};
    if (message.validateInvocation !== undefined) {
      obj.validateInvocation = FunctionInvocation.toJSON(message.validateInvocation);
    }
    if (message.executeInvocation?.$case === "success") {
      obj.success = FunctionInvocation.toJSON(message.executeInvocation.success);
    }
    if (message.executeInvocation?.$case === "reverted") {
      obj.reverted = ExecutionReverted.toJSON(message.executeInvocation.reverted);
    }
    if (message.feeTransferInvocation !== undefined) {
      obj.feeTransferInvocation = FunctionInvocation.toJSON(message.feeTransferInvocation);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeTransactionTrace>): InvokeTransactionTrace {
    return InvokeTransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeTransactionTrace>): InvokeTransactionTrace {
    const message = createBaseInvokeTransactionTrace() as any;
    message.validateInvocation = (object.validateInvocation !== undefined && object.validateInvocation !== null)
      ? FunctionInvocation.fromPartial(object.validateInvocation)
      : undefined;
    if (
      object.executeInvocation?.$case === "success" &&
      object.executeInvocation?.success !== undefined &&
      object.executeInvocation?.success !== null
    ) {
      message.executeInvocation = {
        $case: "success",
        success: FunctionInvocation.fromPartial(object.executeInvocation.success),
      };
    }
    if (
      object.executeInvocation?.$case === "reverted" &&
      object.executeInvocation?.reverted !== undefined &&
      object.executeInvocation?.reverted !== null
    ) {
      message.executeInvocation = {
        $case: "reverted",
        reverted: ExecutionReverted.fromPartial(object.executeInvocation.reverted),
      };
    }
    message.feeTransferInvocation =
      (object.feeTransferInvocation !== undefined && object.feeTransferInvocation !== null)
        ? FunctionInvocation.fromPartial(object.feeTransferInvocation)
        : undefined;
    return message;
  },
};

function createBaseDeclareTransactionTrace(): DeclareTransactionTrace {
  return { validateInvocation: undefined, feeTransferInvocation: undefined };
}

export const DeclareTransactionTrace = {
  encode(message: DeclareTransactionTrace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validateInvocation !== undefined) {
      FunctionInvocation.encode(message.validateInvocation, writer.uint32(10).fork()).ldelim();
    }
    if (message.feeTransferInvocation !== undefined) {
      FunctionInvocation.encode(message.feeTransferInvocation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeclareTransactionTrace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionTrace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validateInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeTransferInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeclareTransactionTrace {
    return {
      validateInvocation: isSet(object.validateInvocation)
        ? FunctionInvocation.fromJSON(object.validateInvocation)
        : undefined,
      feeTransferInvocation: isSet(object.feeTransferInvocation)
        ? FunctionInvocation.fromJSON(object.feeTransferInvocation)
        : undefined,
    };
  },

  toJSON(message: DeclareTransactionTrace): unknown {
    const obj: any = {};
    if (message.validateInvocation !== undefined) {
      obj.validateInvocation = FunctionInvocation.toJSON(message.validateInvocation);
    }
    if (message.feeTransferInvocation !== undefined) {
      obj.feeTransferInvocation = FunctionInvocation.toJSON(message.feeTransferInvocation);
    }
    return obj;
  },

  create(base?: DeepPartial<DeclareTransactionTrace>): DeclareTransactionTrace {
    return DeclareTransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeclareTransactionTrace>): DeclareTransactionTrace {
    const message = createBaseDeclareTransactionTrace() as any;
    message.validateInvocation = (object.validateInvocation !== undefined && object.validateInvocation !== null)
      ? FunctionInvocation.fromPartial(object.validateInvocation)
      : undefined;
    message.feeTransferInvocation =
      (object.feeTransferInvocation !== undefined && object.feeTransferInvocation !== null)
        ? FunctionInvocation.fromPartial(object.feeTransferInvocation)
        : undefined;
    return message;
  },
};

function createBaseDeployAccountTransactionTrace(): DeployAccountTransactionTrace {
  return { validateInvocation: undefined, constructorInvocation: undefined, feeTransferInvocation: undefined };
}

export const DeployAccountTransactionTrace = {
  encode(message: DeployAccountTransactionTrace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validateInvocation !== undefined) {
      FunctionInvocation.encode(message.validateInvocation, writer.uint32(10).fork()).ldelim();
    }
    if (message.constructorInvocation !== undefined) {
      FunctionInvocation.encode(message.constructorInvocation, writer.uint32(18).fork()).ldelim();
    }
    if (message.feeTransferInvocation !== undefined) {
      FunctionInvocation.encode(message.feeTransferInvocation, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployAccountTransactionTrace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionTrace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validateInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constructorInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeTransferInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployAccountTransactionTrace {
    return {
      validateInvocation: isSet(object.validateInvocation)
        ? FunctionInvocation.fromJSON(object.validateInvocation)
        : undefined,
      constructorInvocation: isSet(object.constructorInvocation)
        ? FunctionInvocation.fromJSON(object.constructorInvocation)
        : undefined,
      feeTransferInvocation: isSet(object.feeTransferInvocation)
        ? FunctionInvocation.fromJSON(object.feeTransferInvocation)
        : undefined,
    };
  },

  toJSON(message: DeployAccountTransactionTrace): unknown {
    const obj: any = {};
    if (message.validateInvocation !== undefined) {
      obj.validateInvocation = FunctionInvocation.toJSON(message.validateInvocation);
    }
    if (message.constructorInvocation !== undefined) {
      obj.constructorInvocation = FunctionInvocation.toJSON(message.constructorInvocation);
    }
    if (message.feeTransferInvocation !== undefined) {
      obj.feeTransferInvocation = FunctionInvocation.toJSON(message.feeTransferInvocation);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployAccountTransactionTrace>): DeployAccountTransactionTrace {
    return DeployAccountTransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployAccountTransactionTrace>): DeployAccountTransactionTrace {
    const message = createBaseDeployAccountTransactionTrace() as any;
    message.validateInvocation = (object.validateInvocation !== undefined && object.validateInvocation !== null)
      ? FunctionInvocation.fromPartial(object.validateInvocation)
      : undefined;
    message.constructorInvocation =
      (object.constructorInvocation !== undefined && object.constructorInvocation !== null)
        ? FunctionInvocation.fromPartial(object.constructorInvocation)
        : undefined;
    message.feeTransferInvocation =
      (object.feeTransferInvocation !== undefined && object.feeTransferInvocation !== null)
        ? FunctionInvocation.fromPartial(object.feeTransferInvocation)
        : undefined;
    return message;
  },
};

function createBaseL1HandlerTransactionTrace(): L1HandlerTransactionTrace {
  return { functionInvocation: undefined };
}

export const L1HandlerTransactionTrace = {
  encode(message: L1HandlerTransactionTrace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.functionInvocation !== undefined) {
      FunctionInvocation.encode(message.functionInvocation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): L1HandlerTransactionTrace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransactionTrace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.functionInvocation = FunctionInvocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): L1HandlerTransactionTrace {
    return {
      functionInvocation: isSet(object.functionInvocation)
        ? FunctionInvocation.fromJSON(object.functionInvocation)
        : undefined,
    };
  },

  toJSON(message: L1HandlerTransactionTrace): unknown {
    const obj: any = {};
    if (message.functionInvocation !== undefined) {
      obj.functionInvocation = FunctionInvocation.toJSON(message.functionInvocation);
    }
    return obj;
  },

  create(base?: DeepPartial<L1HandlerTransactionTrace>): L1HandlerTransactionTrace {
    return L1HandlerTransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<L1HandlerTransactionTrace>): L1HandlerTransactionTrace {
    const message = createBaseL1HandlerTransactionTrace() as any;
    message.functionInvocation = (object.functionInvocation !== undefined && object.functionInvocation !== null)
      ? FunctionInvocation.fromPartial(object.functionInvocation)
      : undefined;
    return message;
  },
};

function createBaseFunctionInvocation(): FunctionInvocation {
  return {
    contractAddress: undefined,
    entryPointSelector: undefined,
    calldata: [],
    callerAddress: undefined,
    classHash: undefined,
    callType: 0,
    result: [],
    calls: [],
    events: [],
    messages: [],
  };
}

export const FunctionInvocation = {
  encode(message: FunctionInvocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(18).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.callerAddress !== undefined) {
      FieldElement.encode(message.callerAddress, writer.uint32(34).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    if (message.callType !== undefined && message.callType !== 0) {
      writer.uint32(48).int32(message.callType);
    }
    if (message.result !== undefined && message.result.length !== 0) {
      for (const v of message.result) {
        FieldElement.encode(v!, writer.uint32(58).fork()).ldelim();
      }
    }
    if (message.calls !== undefined && message.calls.length !== 0) {
      for (const v of message.calls) {
        FunctionInvocation.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.events !== undefined && message.events.length !== 0) {
      writer.uint32(74).fork();
      for (const v of message.events) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.messages !== undefined && message.messages.length !== 0) {
      writer.uint32(82).fork();
      for (const v of message.messages) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FunctionInvocation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionInvocation() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.callerAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.callType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.result!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.calls!.push(FunctionInvocation.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag === 72) {
            message.events!.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.events!.push(reader.uint32());
            }

            continue;
          }

          break;
        case 10:
          if (tag === 80) {
            message.messages!.push(reader.uint32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.messages!.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionInvocation {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
      callerAddress: isSet(object.callerAddress) ? FieldElement.fromJSON(object.callerAddress) : undefined,
      classHash: isSet(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      callType: isSet(object.callType) ? callTypeFromJSON(object.callType) : 0,
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => FieldElement.fromJSON(e)) : [],
      calls: globalThis.Array.isArray(object?.calls)
        ? object.calls.map((e: any) => FunctionInvocation.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => globalThis.Number(e)) : [],
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FunctionInvocation): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.callerAddress !== undefined) {
      obj.callerAddress = FieldElement.toJSON(message.callerAddress);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.callType !== undefined && message.callType !== 0) {
      obj.callType = callTypeToJSON(message.callType);
    }
    if (message.result?.length) {
      obj.result = message.result.map((e) => FieldElement.toJSON(e));
    }
    if (message.calls?.length) {
      obj.calls = message.calls.map((e) => FunctionInvocation.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Math.round(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionInvocation>): FunctionInvocation {
    return FunctionInvocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionInvocation>): FunctionInvocation {
    const message = createBaseFunctionInvocation() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.callerAddress = (object.callerAddress !== undefined && object.callerAddress !== null)
      ? FieldElement.fromPartial(object.callerAddress)
      : undefined;
    message.classHash = (object.classHash !== undefined && object.classHash !== null)
      ? FieldElement.fromPartial(object.classHash)
      : undefined;
    message.callType = object.callType ?? 0;
    message.result = object.result?.map((e) => FieldElement.fromPartial(e)) || [];
    message.calls = object.calls?.map((e) => FunctionInvocation.fromPartial(e)) || [];
    message.events = object.events?.map((e) => e) || [];
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}

export const FunctionCall = {
  encode(message: FunctionCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(18).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FunctionCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.calldata!.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet(object.entryPointSelector)
        ? FieldElement.fromJSON(object.entryPointSelector)
        : undefined,
      calldata: globalThis.Array.isArray(object?.calldata)
        ? object.calldata.map((e: any) => FieldElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall() as any;
    message.contractAddress = (object.contractAddress !== undefined && object.contractAddress !== null)
      ? FieldElement.fromPartial(object.contractAddress)
      : undefined;
    message.entryPointSelector = (object.entryPointSelector !== undefined && object.entryPointSelector !== null)
      ? FieldElement.fromPartial(object.entryPointSelector)
      : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds?.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
